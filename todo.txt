DOCS:

- Multiple router instances are possible (explain the implications)

- Integration with luga.history

-------------

ROUTER:

- Routes priority rely on order of inclusion. Routes are processed from top to bottom, the first match win

- Greedy mode allows multiple routes matching(off by default)

- Expose events notification (routeEnter, routeExit)

- Allows arbitrary payload to be passed by a route
- Retrieve state object (if any, created by pushState) to be passed by a route
- Parameters data to be passed by a route
- As many useful data to be passed by a route (including the route object itself)

- The path is a route's unique identifier. Router.add() throws an exception in case of duplicated paths

- Router.add(path, callback|[callback], options) @return {luga.Route}|{custom.Route}
- Router.add({luga.Route})
- Router.remove(path)
- Router.getRoutes() @return array.<{luga.Route}>
- Router.findMatch(fragment) @return {luga.Route}|undefined
- Router.clear() -> remove all routes
- Router.setUp() -> set options

- Router.options = {
     rootPath: {string}
     greedy: {boolean}
}

- Static luga.router.patternLexer class compiles route paths into RegExp

- Route.path
- Route.match(fragment)
- Route.enter()
- Route.exit()

- Use Crossroad-like syntax for paths, closer to Spring MVC and .NET MVC
  https://millermedeiros.github.io/crossroads.js/#crossroads-add_route
  Express's syntax for patterns is too ambiguous, pretty much RegExp:  http://expressjs.com/en/guide/routing.html

- Path can be only string, RegExp are not allowed

- In order to stay isomorphic we can't read HTTP method (Like Spring or .MET MVC)
  We can't handle HTTP headers too (none does)