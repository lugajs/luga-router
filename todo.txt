DOCS:

- Multiple router instances are possible (explain the implications)

- Priority rely on order of registration. RouteHandlers are processed from top to bottom, the first match win.
  If no match is found, nothing happens
- Greedy mode allows multiple routeHandlers matching (false by default). Less efficient

- Router.add() is overloaded, explain signatures
  Path can only be strings, RexExp aren't allowed
  
- Use Crossroad-like syntax for paths, closer to Spring MVC and .NET MVC
  https://millermedeiros.github.io/crossroads.js/#crossroads-add_route
  Express's syntax for patterns is too ambiguous, pretty much RegExp:  http://expressjs.com/en/guide/routing.html 

- Document optional parameters

- routeContext properties: path, fragment, payload, historyState, params

- Router.normalizeHash()
- Router.normalizeFragment()

- Events notification (routeEntered, routeExited)

- Router.add() create instances of luga.RouteHandler by default. You can change this from options or setup()


- Integration with luga.history
  1) hash: call .resolve() passing location.hash minus #
  2) popState: call .resolve() passing document.location.pathname minus options.rootPath

- Document implication of using pushState regarding the server:
  https://github.com/flatiron/director#history-api

-------------

ROUTER:

- Extract queryString from fragment, turn it into an hash and attach to the context

- Enable test on Node.js

-------------

FUTURE:

- In order to stay isomorphic we can't read HTTP method (Like Spring or .MET MVC)
  We can't handle HTTP headers too (other libraries don't either)
  Should we provide a mechanism for Node.js?