{"version":3,"sources":["luga.core.min.js","luga.core.js","luga.string.js","luga.Notifier.js"],"names":["luga","namespace","ns","rootObject","parts","split","undefined","window","globals","i","length","core","version","extend","baseFunc","func","args","apply","isArray","obj","Array","isFunction","type","isPlainObject","Object","prototype","toString","call","proto","getPrototypeOf","constructor","hasOwnProperty","Function","lookupFunction","path","reference","lookupProperty","object","part","shift","merge","target","x","setProperty","value","class2type","forEach","element","collection","toLowerCase","rawType","stringType","string","demoronize","str","replace","RegExp","String","fromCharCode","format","pattern","queryToHash","map","charAt","substring","tokens","fieldName","decodeURIComponent","fieldValue","push","propertyPattern","populate","results","exec","property","test","NOTIFIER_CONST","ERROR_MESSAGES","NOTIFIER_ABSTRACT","INVALID_OBSERVER_PARAMETER","INVALID_DATA_PARAMETER","Notifier","this","observers","prefix","suffix","generateMethodName","eventName","toUpperCase","addObserver","observer","notifyObservers","data","method","removeObserver","splice"],"mappings":"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","file":"luga.core.min.js","sourcesContent":[null,"/* istanbul ignore else */\r\nif(typeof(luga) === \"undefined\"){\r\n\tvar luga = {};\r\n}\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Creates namespaces to be used for scoping variables and classes so that they are not global.\r\n\t * Specifying the last node of a namespace implicitly creates all other nodes.\r\n\t * Based on Nicholas C. Zakas's code\r\n\t * @param {string} ns           Namespace as string\r\n\t * @param {object} rootObject   Optional root object. Default to window\r\n\t */\r\n\tluga.namespace = function(ns, rootObject){\r\n\t\tvar parts = ns.split(\".\");\r\n\t\tif(rootObject === undefined){\r\n\t\t\t// Use window on a browser, globals on Node.js\r\n\t\t\trootObject = window || globals;\r\n\t\t}\r\n\t\tfor(var i = 0; i < parts.length; i++){\r\n\t\t\tif(rootObject[parts[i]] === undefined){\r\n\t\t\t\trootObject[parts[i]] = {};\r\n\t\t\t}\r\n\t\t\trootObject = rootObject[parts[i]];\r\n\t\t}\r\n\t\treturn rootObject;\r\n\t};\r\n\r\n\tluga.namespace(\"luga.core\");\r\n\tluga.core.version = \"0.3.0\";\r\n\r\n\t/**\r\n\t * Offers a simple solution for inheritance among classes\r\n\t *\r\n\t * @param {function} baseFunc  Parent constructor function. Required\r\n\t * @param {function} func      Child constructor function. Required\r\n\t * @param {array}    args      An array of arguments that will be passed to the parent's constructor. Optional\r\n\t */\r\n\tluga.extend = function(baseFunc, func, args){\r\n\t\tbaseFunc.apply(func, args);\r\n\t};\r\n\r\n\t/**\r\n\t * Return true if an object is an array. False otherwise\r\n\t * @param {*} obj\r\n\t * @returns {boolean}\r\n\t */\r\n\tluga.isArray = function(obj){\r\n\t\treturn Array.isArray(obj);\r\n\t};\r\n\r\n\t/**\r\n\t * Return true if an object is a function. False otherwise\r\n\t * @param {*} obj\r\n\t * @returns {boolean}\r\n\t */\r\n\tluga.isFunction = function(obj){\r\n\t\treturn luga.type(obj) === \"function\";\r\n\t};\r\n\r\n\t/**\r\n\t * Return true if an object is a plain object (created using \"{}\" or \"new Object\"). False otherwise\r\n\t * Based on jQuery.isPlainObject()\r\n\t * @param {*} obj\r\n\t * @returns {boolean}\r\n\t */\r\n\tluga.isPlainObject = function(obj){\r\n\t\t// Detect obvious negatives\r\n\t\t// Use Object.prototype.toString to catch host objects\r\n\t\tif(Object.prototype.toString.call(obj) !== \"[object Object]\"){\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar proto = Object.getPrototypeOf(obj);\r\n\r\n\t\t// Objects with no prototype (e.g., Object.create(null)) are plain\r\n\t\tif(proto === null){\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Objects with prototype are plain if they were constructed by a global Object function\r\n\t\tvar constructor = Object.prototype.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n\t\treturn typeof (constructor === \"function\") && (Function.toString.call(constructor) === Function.toString.call(Object));\r\n\t};\r\n\r\n\t/**\r\n\t * Given the name of a function as a string, return the relevant function, if any\r\n\t * Returns undefined, if the reference has not been found\r\n\t * Supports namespaces (if the fully qualified path is passed)\r\n\t * @param {string} path            Fully qualified name of a function\r\n\t * @returns {function|undefined}   The javascript reference to the function, undefined if nothing is fund or if it's not a function\r\n\t */\r\n\tluga.lookupFunction = function(path){\r\n\t\tif(!path){\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\tvar reference = luga.lookupProperty(window, path);\r\n\t\tif(luga.isFunction(reference) === true){\r\n\t\t\treturn reference;\r\n\t\t}\r\n\t\treturn undefined;\r\n\t};\r\n\r\n\t/**\r\n\t * Given an object and a path, returns the property located at the given path\r\n\t * If nothing exists at that location, returns undefined\r\n\t * Supports unlimited nesting levels (if the fully qualified path is passed)\r\n\t * @param {object} object  Target object\r\n\t * @param {string} path    Dot-delimited string\r\n\t * @returns {*|undefined}\r\n\t */\r\n\tluga.lookupProperty = function(object, path){\r\n\t\t// Either of the two params is invalid\r\n\t\tif(!object || !path){\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\t// Property live at the first level\r\n\t\tif(object[path] !== undefined){\r\n\t\t\treturn object[path];\r\n\t\t}\r\n\t\tvar parts = path.split(\".\");\r\n\t\twhile(parts.length > 0){\r\n\t\t\tvar part = parts.shift();\r\n\t\t\tif(object[part] !== undefined){\r\n\t\t\t\tif(parts.length === 0){\r\n\t\t\t\t\t// We got it\r\n\t\t\t\t\treturn object[part];\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t// Keep looping\r\n\t\t\t\t\tobject = object[part];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t};\r\n\r\n\t/**\r\n\t * Shallow-merge the contents of two objects together into the first object\r\n\t *\r\n\t * @param {object} target  An object that will receive the new properties\r\n\t * @param {object} obj     An object containing additional properties to merge in\r\n\t */\r\n\tluga.merge = function(target, obj){\r\n\t\tfor(var x in obj){\r\n\t\t\ttarget[x] = obj[x];\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Given an object, a path and a value, set the property located at the given path to the given value\r\n\t * If the path does not exists, it creates it\r\n\t * @param {object} object  Target object\r\n\t * @param {string} path    Fully qualified property name\r\n\t * @param {*}      value\r\n\t */\r\n\tluga.setProperty = function(object, path, value){\r\n\t\tvar parts = path.split(\".\");\r\n\t\twhile(parts.length > 0){\r\n\t\t\tvar part = parts.shift();\r\n\t\t\tif(object[part] !== undefined){\r\n\t\t\t\t// Keep looping\r\n\t\t\t\tobject = object[part];\r\n\t\t\t}\r\n\t\t\telse if(parts.length > 0){\r\n\t\t\t\t// Create the missing element and keep looping\r\n\t\t\t\tobject[part] = {};\r\n\t\t\t\tobject = object[part];\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tobject[part] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar class2type = {};\r\n\t[\"Array\", \"Boolean\", \"Date\", \"Error\", \"Function\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Symbol\"].forEach(function(element, i, collection){\r\n\t\tclass2type[\"[object \" + element + \"]\"] = element.toLowerCase();\r\n\t});\r\n\r\n\t/**\r\n\t * Determine the internal JavaScript [[Class]] of an object\r\n\t * Based on jQuery.type()\r\n\t * @param {*} obj\r\n\t * @returns {string}\r\n\t */\r\n\tluga.type = function(obj){\r\n\t\tif(obj === null){\r\n\t\t\treturn \"null\";\r\n\t\t}\r\n\t\tvar rawType = typeof obj;\r\n\t\tif((rawType === \"object\") || (rawType === \"function\")){\r\n\t\t\t/* http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/ */\r\n\t\t\tvar stringType = Object.prototype.toString.call(obj);\r\n\t\t\treturn class2type[stringType];\r\n\t\t}\r\n\t\treturn rawType;\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.string\");\r\n\r\n\t/**\r\n\t * Replace MS Word's non-ISO characters with plausible substitutes\r\n\t *\r\n\t * @param {string} str   String containing MS Word's garbage\r\n\t * @returns {string}      The de-moronized string\r\n\t */\r\n\tluga.string.demoronize = function(str){\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(710), \"g\"), \"^\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(732), \"g\"), \"~\");\r\n\t\t// Evil \"smarty\" quotes\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8216), \"g\"), \"'\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8217), \"g\"), \"'\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8220), \"g\"), \"\\\"\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8221), \"g\"), \"\\\"\");\r\n\t\t// More garbage\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8211), \"g\"), \"-\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8212), \"g\"), \"--\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8218), \"g\"), \",\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8222), \"g\"), \",,\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8226), \"g\"), \"*\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8230), \"g\"), \"...\");\r\n\t\treturn str;\r\n\t};\r\n\r\n\t/**\r\n\t * Given a string containing placeholders, it assembles a new string\r\n\t * replacing the placeholders with the strings contained inside the second argument (either an object or an array)\r\n\t * Loosely based on the .NET implementation: http://msdn.microsoft.com/en-us/library/system.string.format.aspx\r\n\t *\r\n\t * Example passing strings inside an array:\r\n\t * luga.string.format(\"My name is {0} {1}\", [\"Ciccio\", \"Pasticcio\"]);\r\n\t * => \"My name is Ciccio Pasticcio\"\r\n\t *\r\n\t * Example passing strings inside an object:\r\n\t * luga.string.format(\"My name is {firstName} {lastName}\", {firstName: \"Ciccio\", lastName: \"Pasticcio\"});\r\n\t * => \"My name is Ciccio Pasticcio\"\r\n\t *\r\n\t * @param  {string}  str                   String containing placeholders\r\n\t * @param  {object|array.<string>} args    Either an array of strings or an objects containing name/value pairs in string format\r\n\t * @returns {string} The newly assembled string\r\n\t */\r\n\tluga.string.format = function(str, args){\r\n\t\tvar pattern = null;\r\n\t\tif(luga.isArray(args) === true){\r\n\t\t\tfor(var i = 0; i < args.length; i++){\r\n\t\t\t\tpattern = new RegExp(\"\\\\{\" + i + \"\\\\}\", \"g\");\r\n\t\t\t\tstr = str.replace(pattern, args[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(luga.isPlainObject(args) === true){\r\n\t\t\tfor(var x in args){\r\n\t\t\t\tpattern = new RegExp(\"\\\\{\" + x + \"\\\\}\", \"g\");\r\n\t\t\t\tstr = str.replace(pattern, args[x]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str;\r\n\t};\r\n\r\n\t/**\r\n\t * Given a string in querystring format, return a JavaScript object containing name/value pairs\r\n\t * @param {string} str  The querystring\r\n\t * @returns {object}\r\n\t */\r\n\tluga.string.queryToHash = function(str){\r\n\t\tvar map = {};\r\n\t\tif(str.charAt(0) === \"?\"){\r\n\t\t\tstr = str.substring(1);\r\n\t\t}\r\n\t\tif(str.length === 0){\r\n\t\t\treturn map;\r\n\t\t}\r\n\t\tvar parts = str.split(\"&\");\r\n\r\n\t\tfor(var i = 0; i < parts.length; i++){\r\n\t\t\tvar tokens = parts[i].split(\"=\");\r\n\t\t\tvar fieldName = decodeURIComponent(tokens[0]);\r\n\t\t\tvar fieldValue = \"\";\r\n\t\t\tif(tokens.length === 2){\r\n\t\t\t\tfieldValue = decodeURIComponent(tokens[1]);\r\n\t\t\t}\r\n\t\t\tif(map[fieldName] === undefined){\r\n\t\t\t\tmap[fieldName] = fieldValue;\r\n\t\t\t}\r\n\t\t\telse if(luga.isArray(map[fieldName]) === true){\r\n\t\t\t\tmap[fieldName].push(fieldValue);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tmap[fieldName] = [map[fieldName], fieldValue];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t};\r\n\r\n\tvar propertyPattern = new RegExp(\"\\\\{([^}]*)}\", \"g\");\r\n\r\n\t/**\r\n\t * Given a string containing placeholders in {key} format, it assembles a new string\r\n\t * populating the placeholders with the strings contained inside the second argument keys\r\n\t * Unlike luga.string.format, placeholders can match nested properties too. But it's slower\r\n\t *\r\n\t * Example:\r\n\t * luga.string.format(\"My name is {firstName} {lastName}\", {firstName: \"Ciccio\", lastName: \"Pasticcio\"});\r\n\t * => \"My name is Ciccio Pasticcio\"\r\n\t *\r\n\t * Example with nested properties:\r\n\t * var nestedObj = { type: \"people\", person: { firstName: \"Ciccio\", lastName: \"Pasticcio\" } };\r\n\t * luga.string.populate(\"My name is {person.firstName} {person.lastName}\", nestedObj)\r\n\t * => \"My name is Ciccio Pasticcio\"\r\n\t *\r\n\t * @param   {string} str   String containing placeholders\r\n\t * @param   {object} obj   An objects containing name/value pairs in string format\r\n\t * @returns {string} The newly assembled string\r\n\t */\r\n\tluga.string.populate = function(str, obj){\r\n\t\tif(luga.isPlainObject(obj) === true){\r\n\t\t\tvar results;\r\n\t\t\twhile((results = propertyPattern.exec(str)) !== null){\r\n\t\t\t\tvar property = luga.lookupProperty(obj, results[1]);\r\n\t\t\t\tif(property !== undefined){\r\n\t\t\t\t\tvar pattern = new RegExp(results[0], \"g\");\r\n\t\t\t\t\tstr = str.replace(pattern, property);\r\n\t\t\t\t\t// Keep searching\r\n\t\t\t\t\tpropertyPattern.test(str);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str;\r\n\t};\r\n\r\n}());","(function(){\r\n\r\n\t\"use strict\";\r\n\r\n\tluga.NOTIFIER_CONST = {\r\n\t\tERROR_MESSAGES: {\r\n\t\t\tNOTIFIER_ABSTRACT: \"It's forbidden to use luga.Notifier directly, it must be used as a base class instead\",\r\n\t\t\tINVALID_OBSERVER_PARAMETER: \"addObserver(): observer parameter must be an object\",\r\n\t\t\tINVALID_DATA_PARAMETER: \"notifyObserver(): data parameter is required and must be an object\"\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Provides the base functionality necessary to maintain a list of observers and send notifications to them.\r\n\t * It's forbidden to use this class directly, it can only be used as a base class.\r\n\t * The Notifier class does not define any notification messages, so it is up to the developer to define the notifications sent via the Notifier.\r\n\t * @throws {Exception}\r\n\t */\r\n\tluga.Notifier = function(){\r\n\t\tif(this.constructor === luga.Notifier){\r\n\t\t\tthrow(luga.NOTIFIER_CONST.ERROR_MESSAGES.NOTIFIER_ABSTRACT);\r\n\t\t}\r\n\t\tthis.observers = [];\r\n\t\tvar prefix = \"on\";\r\n\t\tvar suffix = \"Handler\";\r\n\r\n\t\t// Turns \"complete\" into \"onComplete\"\r\n\t\tvar generateMethodName = function(eventName){\r\n\t\t\tvar str = prefix;\r\n\t\t\tstr += eventName.charAt(0).toUpperCase();\r\n\t\t\tstr += eventName.substring(1);\r\n\t\t\tstr += suffix;\r\n\t\t\treturn str;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Adds an observer object to the list of observers.\r\n\t\t * Observer objects should implement a method that matches a naming convention for the events they are interested in.\r\n\t\t * For an event named \"complete\" they must implement a method named: \"onCompleteHandler\"\r\n\t\t * The interface for this methods is as follows:\r\n\t\t * observer.onCompleteHandler = function(data){};\r\n\t\t * @param  {object} observer  Observer object\r\n\t\t * @throws {Exception}\r\n\t\t */\r\n\t\tthis.addObserver = function(observer){\r\n\t\t\tif(luga.type(observer) !== \"object\"){\r\n\t\t\t\tthrow(luga.NOTIFIER_CONST.ERROR_MESSAGES.INVALID_OBSERVER_PARAMETER);\r\n\t\t\t}\r\n\t\t\tthis.observers.push(observer);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Sends a notification to all interested observers registered with the notifier.\r\n\t\t *\r\n\t\t * @method\r\n\t\t * @param {string}  eventName  Name of the event\r\n\t\t * @param {object}  data       Object containing data to be passed from the point of notification to all interested observers.\r\n\t\t *                             If there is no relevant data to pass, use an empty object.\r\n\t\t * @throws {Exception}\r\n\t\t */\r\n\t\tthis.notifyObservers = function(eventName, data){\r\n\t\t\tif(luga.type(data) !== \"object\"){\r\n\t\t\t\tthrow(luga.NOTIFIER_CONST.ERROR_MESSAGES.INVALID_DATA_PARAMETER);\r\n\t\t\t}\r\n\t\t\tvar method = generateMethodName(eventName);\r\n\t\t\tfor(var i = 0; i < this.observers.length; i++){\r\n\t\t\t\tvar observer = this.observers[i];\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif(observer[method] && luga.isFunction(observer[method])){\r\n\t\t\t\t\tobserver[method](data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Removes the given observer object.\r\n\t\t *\r\n\t\t * @method\r\n\t\t * @param {Object} observer\r\n\t\t */\r\n\t\tthis.removeObserver = function(observer){\r\n\t\t\tfor(var i = 0; i < this.observers.length; i++){\r\n\t\t\t\tif(this.observers[i] === observer){\r\n\t\t\t\t\tthis.observers.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}