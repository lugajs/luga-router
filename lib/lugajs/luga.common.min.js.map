{"version":3,"sources":["luga.common.js"],"names":["window","luga","namespace","ns","rootObject","parts","split","undefined","i","length","common","version","extend","baseFunc","func","args","apply","isPlainObject","obj","Object","prototype","toString","call","proto","getPrototypeOf","constructor","hasOwnProperty","Function","lookupFunction","path","reference","lookupProperty","type","object","part","shift","merge","target","source","x","setProperty","value","TO_QUERY_STRING_CONST","ERROR_INPUT","toQueryString","input","str","Array","isArray","forEach","element","appendQueryString","class2type","toLowerCase","rawType","stringType","NOTIFIER_CONST","ERROR_MESSAGES","NOTIFIER_ABSTRACT","INVALID_GENERIC_OBSERVER_PARAMETER","INVALID_EVENT_OBSERVER_PARAMETER","INVALID_DATA_PARAMETER","Notifier","this","observers","eventObservers","addObserver","observer","eventName","methodName","arguments","push","eventMap","findObserverIndex","eventArray","currentMap","notifyObservers","payload","genericMethod","charAt","toUpperCase","substring","generateGenericMethodName","removeObserver","splice","index","dom","delegateEvent","node","eventType","selector","callback","addEventListener","event","currentElement","nodeMatches","matches","msMatchesSelector","ready","fn","document","getIteratorInstance","rootNode","filterFunc","filter","NodeFilter","FILTER_SKIP","FILTER_ACCEPT","safeFilter","acceptNode","createTreeWalker","SHOW_ELEMENT","createNodeIterator","nodeIterator","getInstance","treeWalker","form","CONST","FIELD_SELECTOR","FAKE_INPUT_TYPES","fieldset","reset","MESSAGES","MISSING_FORM","toMap","demoronize","map","fields","utils","getChildFields","isSuccessfulField","fieldName","getAttribute","fieldValue","getMultiSelectValue","checked","string","options","querySelectorAll","toJson","flatData","jsonData","multiValues","j","encodeURIComponent","fieldNode","isInputField","disabled","getFieldGroup","name","body","nodes","slice","localStorage","retrieve","root","getRootState","persist","json","setRootState","setItem","JSON","stringify","rootJson","getItem","parse","replace","RegExp","String","fromCharCode","format","pattern","queryToMap","tokens","decodeURIComponent","propertyPattern","populate","results","exec","property","test","XHR_CONST","POST_CONTENT_TYPE","xhr","Request","config","method","success","res","console","debug","error","timeout","async","cache","headers","requestedWith","contentType","self","XMLHttpRequest","assembleResponse","status","statusText","responseText","responseType","responseXML","pop","item","ret","header","headersToArray","getAllResponseHeaders","checkReadyState","readyState","httpStatus","abort","isRequestPending","send","url","params","suffix","Date","now","indexOf","finalizeUrl","open","onreadystatechange","setRequestHeader","finalizeRequest"],"mappings":"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","file":"luga.common.min.js","sourcesContent":["/*! \nLuga Common 0.9.8 2018-04-09T01:00:35.180Z\nhttp://www.lugajs.org\nCopyright 2013-2018 Massimo Foti (massimo@massimocorner.com)\nLicensed under the Apache License, Version 2.0 | http://www.apache.org/licenses/LICENSE-2.0\n */\n/* istanbul ignore else */\r\nif(typeof(luga) === \"undefined\"){\r\n\twindow.luga = {};\r\n}\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Creates namespaces to be used for scoping variables and classes so that they are not global.\r\n\t * Specifying the last node of a namespace implicitly creates all other nodes.\r\n\t * Based on Nicholas C. Zakas's code\r\n\t * @param {String} ns                   Namespace as dot-delimited string\r\n\t * @param {Object} [rootObject=window]  Optional root object. Default to window\r\n\t * @return {Object}\r\n\t */\r\n\tluga.namespace = function(ns, rootObject){\r\n\t\tconst parts = ns.split(\".\");\r\n\t\tif(rootObject === undefined){\r\n\t\t\trootObject = window;\r\n\t\t}\r\n\t\tfor(let i = 0; i < parts.length; i++){\r\n\t\t\tif(rootObject[parts[i]] === undefined){\r\n\t\t\t\trootObject[parts[i]] = {};\r\n\t\t\t}\r\n\t\t\trootObject = rootObject[parts[i]];\r\n\t\t}\r\n\t\treturn rootObject;\r\n\t};\r\n\r\n\tluga.namespace(\"luga.common\");\r\n\tluga.common.version = \"0.9.8\";\r\n\r\n\t/**\r\n\t * Offers a simple solution for inheritance among classes\r\n\t *\r\n\t * @param {Function} baseFunc  Parent constructor function. Required\r\n\t * @param {Function} func      Child constructor function. Required\r\n\t * @param {Array}    [args]    An array of arguments that will be passed to the parent's constructor. Optional\r\n\t */\r\n\tluga.extend = function(baseFunc, func, args){\r\n\t\tbaseFunc.apply(func, args);\r\n\t};\r\n\r\n\t/**\r\n\t * Return true if an object is a plain object (created using \"{}\" or \"new Object\"). False otherwise\r\n\t * Based on jQuery.isPlainObject()\r\n\t * @param {*} obj\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.isPlainObject = function(obj){\r\n\t\t// Detect obvious negatives\r\n\t\t// Use Object.prototype.toString to catch host objects\r\n\t\tif(Object.prototype.toString.call(obj) !== \"[object Object]\"){\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst proto = Object.getPrototypeOf(obj);\r\n\r\n\t\t// Objects with no prototype (e.g., Object.create(null)) are plain\r\n\t\tif(proto === null){\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Objects with prototype are plain if they were constructed by a global Object function\r\n\t\tconst constructor = Object.prototype.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n\t\tif(constructor === false){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn typeof (constructor === \"function\") && (Function.toString.call(constructor) === Function.toString.call(Object));\r\n\t};\r\n\r\n\t/**\r\n\t * Given the name of a function as a string, return the relevant function, if any\r\n\t * Returns undefined, if the reference has not been found\r\n\t * Supports namespaces (if the fully qualified path is passed)\r\n\t * @param {String} path            Fully qualified name of a function\r\n\t * @return {Function|undefined}    The javascript reference to the function, undefined if nothing is fund or if it's not a function\r\n\t */\r\n\tluga.lookupFunction = function(path){\r\n\t\tif(!path){\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\tconst reference = luga.lookupProperty(window, path);\r\n\t\tif(luga.type(reference) === \"function\"){\r\n\t\t\treturn reference;\r\n\t\t}\r\n\t\treturn undefined;\r\n\t};\r\n\r\n\t/**\r\n\t * Given an object and a path, returns the property located at the given path\r\n\t * If nothing exists at that location, returns undefined\r\n\t * Supports unlimited nesting levels (if the fully qualified path is passed)\r\n\t * @param {Object} object  Target object\r\n\t * @param {String} path    Dot-delimited string\r\n\t * @return {*|undefined}\r\n\t */\r\n\tluga.lookupProperty = function(object, path){\r\n\t\t// Either of the two params is invalid\r\n\t\tif(!object || !path){\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\t// Property live at the first level\r\n\t\tif(object[path] !== undefined){\r\n\t\t\treturn object[path];\r\n\t\t}\r\n\t\tconst parts = path.split(\".\");\r\n\t\twhile(parts.length > 0){\r\n\t\t\tconst part = parts.shift();\r\n\t\t\tif(object[part] !== undefined){\r\n\t\t\t\tif(parts.length === 0){\r\n\t\t\t\t\t// We got it\r\n\t\t\t\t\treturn object[part];\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t// Keep looping\r\n\t\t\t\t\tobject = object[part];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t};\r\n\r\n\t/**\r\n\t * Shallow-merge the contents of two objects together into the first object\r\n\t *\r\n\t * @param {Object} target     An object that will receive the new properties\r\n\t * @param {Object} source     An object containing additional properties to merge in\r\n\t */\r\n\tluga.merge = function(target, source){\r\n\t\tfor(let x in source){\r\n\t\t\tif(source.hasOwnProperty(x) === true){\r\n\t\t\t\ttarget[x] = source[x];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Given an object, a path and a value, set the property located at the given path to the given value\r\n\t * If the path does not exists, it creates it\r\n\t * @param {Object} object  Target object\r\n\t * @param {String} path    Fully qualified property name\r\n\t * @param {*}      value\r\n\t */\r\n\tluga.setProperty = function(object, path, value){\r\n\t\tconst parts = path.split(\".\");\r\n\t\tif(parts.length === 1){\r\n\t\t\tobject[path] = value;\r\n\t\t}\r\n\t\twhile(parts.length > 0){\r\n\t\t\tconst part = parts.shift();\r\n\t\t\tif(object[part] !== undefined){\r\n\t\t\t\tif(parts.length === 0){\r\n\t\t\t\t\t// Update\r\n\t\t\t\t\tobject[part] = value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// Keep looping\r\n\t\t\t\tobject = object[part];\r\n\t\t\t}\r\n\t\t\telse if(parts.length > 0){\r\n\t\t\t\t// Create the missing element and keep looping\r\n\t\t\t\tobject[part] = {};\r\n\t\t\t\tobject = object[part];\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tobject[part] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tluga.TO_QUERY_STRING_CONST = {\r\n\t\tERROR_INPUT: \"luga.toQueryString: Can serialize only plain objects\"\r\n\t};\r\n\r\n\t/**\r\n\t * Create a query string out of a plain object containing name/value pairs\r\n\t * @param {Object} input\r\n\t * @return {String}\r\n\t */\r\n\tluga.toQueryString = function(input){\r\n\t\tif(luga.isPlainObject(input) === false){\r\n\t\t\tthrow(luga.TO_QUERY_STRING_CONST.ERROR_INPUT);\r\n\t\t}\r\n\t\tlet str = \"\";\r\n\t\tfor(let x in input){\r\n\t\t\t// Assume is just an array of simple values\r\n\t\t\tif(Array.isArray(input[x]) === true){\r\n\t\t\t\tinput[x].forEach(function(element){\r\n\t\t\t\t\tstr = appendQueryString(str, x, element);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t// Assume it is just name/value pair\r\n\t\t\t\tstr = appendQueryString(str, x, input[x]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str;\r\n\t};\r\n\r\n\tconst class2type = {};\r\n\t[\"Array\", \"Boolean\", \"Date\", \"Error\", \"Function\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Symbol\"].forEach(function(element){\r\n\t\tclass2type[\"[object \" + element + \"]\"] = element.toLowerCase();\r\n\t});\r\n\r\n\t/**\r\n\t * Determine the internal JavaScript [[Class]] of an object\r\n\t * Based on jQuery.type()\r\n\t * @param {*} obj\r\n\t * @return {String}\r\n\t */\r\n\tluga.type = function(obj){\r\n\t\tif(obj === null){\r\n\t\t\treturn \"null\";\r\n\t\t}\r\n\t\tconst rawType = typeof obj;\r\n\t\tif((rawType === \"object\") || (rawType === \"function\")){\r\n\t\t\t/* http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/ */\r\n\t\t\tconst stringType = Object.prototype.toString.call(obj);\r\n\t\t\treturn class2type[stringType];\r\n\t\t}\r\n\t\treturn rawType;\r\n\t};\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.eventObserverMap\r\n\t *\r\n\t * @property {Object} observer\r\n\t * @property {String} methodName\r\n\t */\r\n\r\n\tluga.NOTIFIER_CONST = {\r\n\t\tERROR_MESSAGES: {\r\n\t\t\tNOTIFIER_ABSTRACT: \"It's forbidden to use luga.Notifier directly, it must be used as a base class instead\",\r\n\t\t\tINVALID_GENERIC_OBSERVER_PARAMETER: \"addObserver(): observer parameter must be an object\",\r\n\t\t\tINVALID_EVENT_OBSERVER_PARAMETER: \"addObserver(): eventName and methodName must be strings\",\r\n\t\t\tINVALID_DATA_PARAMETER: \"notifyObserver(): data parameter is required and must be an object\"\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Provides the base functionality necessary to maintain a list of observers and send notifications to them.\r\n\t * It's forbidden to use this class directly, it can only be used as a base class.\r\n\t * The Notifier class does not define any notification messages, so it is up to the developer to define the notifications sent via the Notifier.\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.Notifier = function(){\r\n\t\tif(this.constructor === luga.Notifier){\r\n\t\t\tthrow(luga.NOTIFIER_CONST.ERROR_MESSAGES.NOTIFIER_ABSTRACT);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @type {Array.<Object>}\r\n\t\t */\r\n\t\tthis.observers = [];\r\n\r\n\t\t/**\r\n\t\t * @type {Object.<String, Array.<luga.eventObserverMap>>}\r\n\t\t */\r\n\t\tthis.eventObservers = {};\r\n\r\n\t\tconst prefix = \"on\";\r\n\t\tconst suffix = \"Handler\";\r\n\r\n\t\t// Turns \"complete\" into \"onComplete\"\r\n\t\tconst generateGenericMethodName = function(eventName){\r\n\t\t\tlet str = prefix;\r\n\t\t\tstr += eventName.charAt(0).toUpperCase();\r\n\t\t\tstr += eventName.substring(1);\r\n\t\t\tstr += suffix;\r\n\t\t\treturn str;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Register an observer object.\r\n\t\t * This method is overloaded. You can either invoke it with one or three arguments\r\n\t\t *\r\n\t\t * If you only pass one argument, the given object will be registered as \"generic\" observer\r\n\t\t * \"Generic\" observer objects should implement a method that matches a naming convention for the events they are interested in.\r\n\t\t * For an event named \"complete\" they must implement a method named: \"onCompleteHandler\"\r\n\t\t * The interface for this methods is as follows:\r\n\t\t * observer.onCompleteHandler = function(data){};\r\n\t\t *\r\n\t\t * If you pass three arguments, the first is the object that will be registered as \"event\" observer\r\n\t\t * The second argument is the event name\r\n\t\t * The third argument is the method of the object that will be invoked once the given event is triggered\r\n\t\t *\r\n\t\t * The interface for this methods is as follows:\r\n\t\t * observer[methodName] = function(data){};\r\n\t\t *\r\n\t\t * @param  {Object} observer  Observer object\r\n\t\t * @param {String} [eventName]\r\n\t\t * @param {String} [methodName]\r\n\t\t * @throw {Exception}\r\n\t\t */\r\n\t\tthis.addObserver = function(observer, eventName, methodName){\r\n\t\t\tif(luga.type(observer) !== \"object\"){\r\n\t\t\t\tthrow(luga.NOTIFIER_CONST.ERROR_MESSAGES.INVALID_GENERIC_OBSERVER_PARAMETER);\r\n\t\t\t}\r\n\t\t\tif(arguments.length === 1){\r\n\t\t\t\tthis.observers.push(observer);\r\n\t\t\t}\r\n\t\t\tif(arguments.length === 3){\r\n\t\t\t\tif(luga.type(eventName) !== \"string\" || luga.type(methodName) !== \"string\"){\r\n\t\t\t\t\tthrow(luga.NOTIFIER_CONST.ERROR_MESSAGES.INVALID_EVENT_OBSERVER_PARAMETER);\r\n\t\t\t\t}\r\n\t\t\t\t/**\r\n\t\t\t\t * @type {luga.eventObserverMap}\r\n\t\t\t\t */\r\n\t\t\t\tconst eventMap = {\r\n\t\t\t\t\tobserver: observer,\r\n\t\t\t\t\tmethodName: methodName\r\n\t\t\t\t};\r\n\t\t\t\t// First entry for the given event\r\n\t\t\t\tif(this.eventObservers[eventName] === undefined){\r\n\t\t\t\t\tthis.eventObservers[eventName] = [eventMap];\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(findObserverIndex(this.eventObservers[eventName], eventMap) === -1){\r\n\t\t\t\t\t\tthis.eventObservers[eventName].push(eventMap);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @param {Array.<luga.eventObserverMap>} eventArray\r\n\t\t * @param {luga.eventObserverMap} eventMap\r\n\t\t * @return {Number}\r\n\t\t */\r\n\t\tconst findObserverIndex = function(eventArray, eventMap){\r\n\t\t\tfor(let i = 0; i < eventArray.length; i++){\r\n\t\t\t\t/**\r\n\t\t\t\t * @type {luga.eventObserverMap}\r\n\t\t\t\t */\r\n\t\t\t\tconst currentMap = eventArray[i];\r\n\t\t\t\tif(currentMap.observer === eventMap.observer && currentMap.methodName === eventMap.methodName){\r\n\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Sends a notification to all relevant observers\r\n\t\t *\r\n\t\t * @method\r\n\t\t * @param {String}  eventName  Name of the event\r\n\t\t * @param {Object}  payload    Object containing data to be passed from the point of notification to all interested observers.\r\n\t\t *                             If there is no relevant data to pass, use an empty object.\r\n\t\t * @throw {Exception}\r\n\t\t */\r\n\t\tthis.notifyObservers = function(eventName, payload){\r\n\t\t\tif(luga.type(payload) !== \"object\"){\r\n\t\t\t\tthrow(luga.NOTIFIER_CONST.ERROR_MESSAGES.INVALID_DATA_PARAMETER);\r\n\t\t\t}\r\n\t\t\t// \"Generic\" observers\r\n\t\t\tconst genericMethod = generateGenericMethodName(eventName);\r\n\t\t\tthis.observers.forEach(function(element){\r\n\t\t\t\tif((element[genericMethod] !== undefined) && (luga.type(element[genericMethod]) === \"function\")){\r\n\t\t\t\t\telement[genericMethod](payload);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t// \"Event\" observers\r\n\t\t\tconst eventObservers = this.eventObservers[eventName];\r\n\t\t\tif(eventObservers !== undefined){\r\n\t\t\t\teventObservers.forEach(function(element){\r\n\t\t\t\t\tif(luga.type(element.observer[element.methodName]) === \"function\"){\r\n\t\t\t\t\t\telement.observer[element.methodName](payload);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Removes the given observer object.\r\n\t\t * This method is overloaded. You can either invoke it with one or three arguments\r\n\t\t *\r\n\t\t * If you only pass one argument, the given observer will be removed as \"generic\" observer\r\n\t\t *\r\n\t\t * If you pass three arguments, the given observer will be removed as \"event\" observer associated with the given event and method\r\n\t\t *\r\n\t\t * @method\r\n\t\t * @param {Object} observer\r\n\t\t * @param {String} [eventName]\r\n\t\t * @param {String} [methodName]\r\n\t\t */\r\n\t\tthis.removeObserver = function(observer, eventName, methodName){\r\n\t\t\tif(arguments.length === 1){\r\n\t\t\t\tfor(let i = 0; i < this.observers.length; i++){\r\n\t\t\t\t\tif(this.observers[i] === observer){\r\n\t\t\t\t\t\tthis.observers.splice(i, 1);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(arguments.length === 3){\r\n\t\t\t\tif(this.eventObservers[eventName] !== undefined){\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @type {luga.eventObserverMap}\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconst eventMap = {\r\n\t\t\t\t\t\tobserver: observer,\r\n\t\t\t\t\t\tmethodName: methodName\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst index = findObserverIndex(this.eventObservers[eventName], eventMap);\r\n\t\t\t\t\t// We have a matching entry\r\n\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\tif(index !== -1){\r\n\t\t\t\t\t\tthis.eventObservers[eventName].splice(index, 1);\r\n\t\t\t\t\t\t// Delete empty entries\r\n\t\t\t\t\t\tif(this.eventObservers[eventName].length === 0){\r\n\t\t\t\t\t\t\tdelete this.eventObservers[eventName];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t/* DOM */\r\n\r\n\tluga.namespace(\"luga.dom\");\r\n\r\n\t/**\r\n\t * Attach a single event listener, to a parent element, that will fire for all descendants matching a selector\r\n\t * No matter whether those descendants exist now or are added in the future\r\n\t * @param {HTMLElement} node\r\n\t * @param {String} eventType\r\n\t * @param {String} selector\r\n\t * @param {Function} callback\r\n\t */\r\n\tluga.dom.delegateEvent = function(node, eventType, selector, callback){\r\n\t\tnode.addEventListener(eventType, function(/** @type {Event} */ event){\r\n\t\t\t/** @type {Element} */\r\n\t\t\tconst currentElement = event.target;\r\n\t\t\tif(luga.dom.nodeMatches(currentElement, selector) === true){\r\n\t\t\t\tcallback(event, currentElement);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\t/**\r\n\t * Equalize element.matches across browsers\r\n\t * @param {HTMLElement} node\r\n\t * @param {String} selector\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.dom.nodeMatches = function(node, selector){\r\n\t\tlet methodName = \"matches\";\r\n\t\t// Deal with IE11 without polyfills\r\n\t\t/* istanbul ignore next IE-only */\r\n\t\tif(node.matches === undefined && node.msMatchesSelector !== undefined){\r\n\t\t\tmethodName = \"msMatchesSelector\";\r\n\t\t}\r\n\t\treturn node[methodName](selector);\r\n\t};\r\n\r\n\t/**\r\n\t * Invoke a function as soon as the DOM is loaded\r\n\t * @param {Function} fn\r\n\t */\r\n\tluga.dom.ready = function(fn){\r\n\t\tdocument.addEventListener(\"DOMContentLoaded\", fn);\r\n\t};\r\n\r\n\t/**\r\n\t * Static factory to create a cross-browser either DOM NodeIterator or TreeWalker\r\n\t *\r\n\t * @param {String}                   type        Either \"NodeIterator\" or \"TreeWalker\"\r\n\t * @param {HTMLElement}              rootNode    Start node. Required\r\n\t * @param {Function} [filterFunc]    filterFunc  Optional filter function. If specified only nodes matching the filter will be accepted\r\n\t *                                               The function will be invoked with this signature: filterFunc(node). Must return true|false\r\n\t * @return {NodeIterator|TreeWalker}\r\n\t */\r\n\tconst getIteratorInstance = function(type, rootNode, filterFunc){\r\n\r\n\t\tconst filter = {\r\n\t\t\tacceptNode: function(node){\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif(filterFunc !== undefined){\r\n\t\t\t\t\tif(filterFunc(node) === false){\r\n\t\t\t\t\t\treturn NodeFilter.FILTER_SKIP;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// http://stackoverflow.com/questions/5982648/recommendations-for-working-around-ie9-treewalker-filter-bug\r\n\t\t// A true W3C-compliant nodeFilter object isn't passed, and instead a \"safe\" one _based_ off of the real one.\r\n\t\tconst safeFilter = filter.acceptNode;\r\n\t\tsafeFilter.acceptNode = filter.acceptNode;\r\n\t\tif(type === \"TreeWalker\"){\r\n\t\t\treturn document.createTreeWalker(rootNode, NodeFilter.SHOW_ELEMENT, safeFilter, false);\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn document.createNodeIterator(rootNode, NodeFilter.SHOW_ELEMENT, safeFilter, false);\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tluga.namespace(\"luga.dom.nodeIterator\");\r\n\r\n\t/**\r\n\t * Static factory to create a cross-browser DOM NodeIterator\r\n\t * https://developer.mozilla.org/en-US/docs/Web/API/NodeIterator\r\n\t *\r\n\t * @param {HTMLElement}              rootNode    Start node. Required\r\n\t * @param {Function} [filterFunc]    filterFunc  Optional filter function. If specified only nodes matching the filter will be accepted\r\n\t *                                               The function will be invoked with this signature: filterFunc(node). Must return true|false\r\n\t * @return {NodeIterator}\r\n\t */\r\n\tluga.dom.nodeIterator.getInstance = function(rootNode, filterFunc){\r\n\t\treturn getIteratorInstance(\"NodeIterator\", rootNode, filterFunc);\r\n\t};\r\n\r\n\tluga.namespace(\"luga.dom.treeWalker\");\r\n\r\n\t/**\r\n\t * Static factory to create a cross-browser DOM TreeWalker\r\n\t * https://developer.mozilla.org/en/docs/Web/API/TreeWalker\r\n\t *\r\n\t * @param {HTMLElement}              rootNode    Start node. Required\r\n\t * @param {Function} [filterFunc]    filterFunc  Optional filter function. If specified only nodes matching the filter will be accepted\r\n\t *                                   The function will be invoked with this signature: filterFunc(node). Must return true|false\r\n\t * @return {TreeWalker}\r\n\t */\r\n\tluga.dom.treeWalker.getInstance = function(rootNode, filterFunc){\r\n\t\treturn getIteratorInstance(\"TreeWalker\", rootNode, filterFunc);\r\n\t};\r\n\r\n\t/* Form */\r\n\r\n\tluga.namespace(\"luga.form\");\r\n\r\n\tluga.form.CONST = {\r\n\t\tFIELD_SELECTOR: \"input,select,textarea\",\r\n\t\tFAKE_INPUT_TYPES: {\r\n\t\t\tfieldset: true,\r\n\t\t\treset: true\r\n\t\t},\r\n\t\tMESSAGES: {\r\n\t\t\tMISSING_FORM: \"Unable to load form\"\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a JavaScript object containing name/value pairs from fields contained inside a given root node\r\n\t * Only fields considered successful are returned:\r\n\t * http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.2\r\n\t * Values of multiple checked checkboxes and multiple select are included as a single entry, with array value\r\n\t *\r\n\t * @param {HTMLElement} rootNode     DOM node wrapping the form fields. Required\r\n\t * @param {Boolean}     demoronize   If true, MS Word's special chars are replaced with plausible substitutes. Default to false\r\n\t * @return {Object}                  A JavaScript object containing name/value pairs\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.form.toMap = function(rootNode, demoronize){\r\n\t\tif(rootNode === null){\r\n\t\t\tthrow(luga.form.CONST.MESSAGES.MISSING_FORM);\r\n\t\t}\r\n\t\tconst map = {};\r\n\t\tconst fields = luga.form.utils.getChildFields(rootNode);\r\n\r\n\t\tfor(let i = 0; i < fields.length; i++){\r\n\t\t\tconst element = fields[i];\r\n\t\t\tif(luga.form.utils.isSuccessfulField(element) === true){\r\n\t\t\t\tconst fieldName = element.getAttribute(\"name\");\r\n\t\t\t\tlet fieldValue = null;\r\n\t\t\t\tconst fieldType = element.type;\r\n\t\t\t\tswitch(fieldType){\r\n\r\n\t\t\t\t\tcase \"select-multiple\":\r\n\t\t\t\t\t\tfieldValue = getMultiSelectValue(element);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"checkbox\":\r\n\t\t\t\t\tcase \"radio\":\r\n\t\t\t\t\t\tif(element.checked === true){\r\n\t\t\t\t\t\t\tfieldValue = element.value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tfieldValue = element.value;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(fieldValue !== null){\r\n\t\t\t\t\tif(demoronize === true){\r\n\t\t\t\t\t\tfieldValue = luga.string.demoronize(fieldValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(map[fieldName] === undefined){\r\n\t\t\t\t\t\tmap[fieldName] = fieldValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(Array.isArray(map[fieldName]) === true){\r\n\t\t\t\t\t\tmap[fieldName].push(fieldValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tmap[fieldName] = [map[fieldName], fieldValue];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {HTMLElement} node\r\n\t * @return {Array.<String>}\r\n\t */\r\n\tconst getMultiSelectValue = function(node){\r\n\t\tconst fieldValue = [];\r\n\t\tconst options = node.querySelectorAll(\"option:checked\");\r\n\t\tfor(let i = 0; i < options.length; i++){\r\n\t\t\tfieldValue.push(options[i].value);\r\n\t\t}\r\n\t\treturn fieldValue;\r\n\t};\r\n\r\n\t/**\r\n\t * Given a form node or another element wrapping input fields, serialize their value into JSON data\r\n\t * If fields names contains dots, their are handled as nested properties\r\n\t * Only fields considered successful are returned:\r\n\t * http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.2\r\n\t * @param {HTMLElement} rootNode  DOM node wrapping the form fields\r\n\t * @return {json}\r\n\t */\r\n\tluga.form.toJson = function(rootNode){\r\n\t\tconst flatData = luga.form.toMap(rootNode);\r\n\t\tconst jsonData = {};\r\n\t\tfor(let x in flatData){\r\n\t\t\tluga.setProperty(jsonData, x, flatData[x]);\r\n\t\t}\r\n\t\treturn jsonData;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a URI encoded string of name/value pairs from fields contained inside a given root node\r\n\t * Only fields considered successful are returned:\r\n\t * http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.2\r\n\t *\r\n\t * @param {HTMLElement} rootNode    DOM node wrapping the form fields. Required\r\n\t * @param {Boolean}     demoronize  If set to true, MS Word's special chars are replaced with plausible substitutes. Default to false\r\n\t * @return {String}                 A URI encoded string\r\n\t * @throw {Exception}\r\n\t */\r\n\tluga.form.toQueryString = function(rootNode, demoronize){\r\n\t\tif(rootNode === null){\r\n\t\t\tthrow(luga.form.CONST.MESSAGES.MISSING_FORM);\r\n\t\t}\r\n\t\tlet str = \"\";\r\n\t\tconst fields = luga.form.utils.getChildFields(rootNode);\r\n\r\n\t\tfor(let i = 0; i < fields.length; i++){\r\n\t\t\tconst element = fields[i];\r\n\t\t\tif(luga.form.utils.isSuccessfulField(element) === true){\r\n\t\t\t\tconst fieldName = element.getAttribute(\"name\");\r\n\t\t\t\tconst fieldType = element.type;\r\n\t\t\t\tswitch(fieldType){\r\n\r\n\t\t\t\t\t/* eslint-disable no-case-declarations */\r\n\t\t\t\t\tcase \"select-multiple\":\r\n\t\t\t\t\t\tconst multiValues = getMultiSelectValue(element);\r\n\t\t\t\t\t\tfor(let j = 0; j < multiValues.length; j++){\r\n\t\t\t\t\t\t\tstr = appendQueryString(str, fieldName, multiValues[i], demoronize);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"checkbox\":\r\n\t\t\t\t\tcase \"radio\":\r\n\t\t\t\t\t\tif(element.checked === true){\r\n\t\t\t\t\t\t\tstr = appendQueryString(str, fieldName, element.value, demoronize);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tstr = appendQueryString(str, fieldName, element.value, demoronize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str;\r\n\t};\r\n\r\n\tconst appendQueryString = function(str, fieldName, fieldValue, demoronize){\r\n\t\tif(str !== \"\"){\r\n\t\t\tstr += \"&\";\r\n\t\t}\r\n\t\tstr += encodeURIComponent(fieldName);\r\n\t\tstr += \"=\";\r\n\t\tif(demoronize === true){\r\n\t\t\tstr += encodeURIComponent(luga.string.demoronize(fieldValue));\r\n\t\t}\r\n\t\telse{\r\n\t\t\tstr += encodeURIComponent(fieldValue);\r\n\t\t}\r\n\t\treturn str;\r\n\t};\r\n\r\n\tluga.namespace(\"luga.form.utils\");\r\n\r\n\t/**\r\n\t * Returns true if the given DOM field is successful, false otherwise\r\n\t * http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.2\r\n\t *\r\n\t * @param {HTMLElement}  fieldNode\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.form.utils.isSuccessfulField = function(fieldNode){\r\n\t\tif(luga.form.utils.isInputField(fieldNode) === false){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(fieldNode.disabled === true){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(fieldNode.getAttribute(\"name\") === null){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns true if the passed node is a form field that we care about\r\n\t *\r\n\t * @param {HTMLElement}  fieldNode\r\n\t * @return {Boolean}\r\n\t */\r\n\tluga.form.utils.isInputField = function(fieldNode){\r\n\t\tif(fieldNode.type === undefined){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// It belongs to the kind of nodes that are considered form fields, but we don't care about\r\n\t\tif(luga.form.CONST.FAKE_INPUT_TYPES[fieldNode.type] === true){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Extracts group of fields that share the same name from a given root node\r\n\t * Or the whole document if the second argument is not passed\r\n\t *\r\n\t * @param {String} name              Name of the field. Mandatory\r\n\t * @param {HTMLElement} [rootNode]   Root node, optional, default to document.body\r\n\t * @return {Array.<HTMLElement>}\r\n\t */\r\n\tluga.form.utils.getFieldGroup = function(name, rootNode){\r\n\t\tif(rootNode === undefined){\r\n\t\t\trootNode = document.body;\r\n\t\t}\r\n\t\tconst selector = \"input[name='\" + name + \"']\";\r\n\t\tconst nodes = rootNode.querySelectorAll(selector);\r\n\t\t// Turn nodelist into an array to be consistent with .getChildFields()\r\n\t\treturn Array.prototype.slice.call(nodes);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns an array of input fields contained inside a given root node\r\n\t *\r\n\t * @param {HTMLElement}  rootNode   Root node\r\n\t * @return {Array.<HTMLElement>}\r\n\t */\r\n\tluga.form.utils.getChildFields = function(rootNode){\r\n\t\tconst fields = [];\r\n\t\tconst nodes = rootNode.querySelectorAll(luga.form.CONST.FIELD_SELECTOR);\r\n\t\tfor(let i = 0; i < nodes.length; i++){\r\n\t\t\tconst element = nodes[i];\r\n\t\t\tif(luga.form.utils.isInputField(element) === true){\r\n\t\t\t\tfields.push(element);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn fields;\r\n\t};\r\n\r\n\tluga.namespace(\"luga.localStorage\");\r\n\r\n\t/**\r\n\t * Retrieve from localStorage the string corresponding to the given combination of root and path\r\n\t * Returns undefined if nothing matches the given root/path\r\n\t * @param {String} root    Top-level key inside localStorage\r\n\t * @param {String} path    Dot-delimited string\r\n\t * @return {*|undefined}\r\n\t */\r\n\tluga.localStorage.retrieve = function(root, path){\r\n\t\treturn luga.lookupProperty(getRootState(root), path.toString());\r\n\t};\r\n\r\n\t/**\r\n\t * Persist the given string inside localStorage, under the given combination of root and path\r\n\t * The ability to pass a dot-delimited path allow to protect the information from name clashes\r\n\t * @param {String} root    Top-level key inside localStorage\r\n\t * @param {String} path    Dot-delimited string\r\n\t * @param {String} value   String to be persisted\r\n\t */\r\n\tluga.localStorage.persist = function(root, path, value){\r\n\t\tconst json = getRootState(root);\r\n\t\tluga.setProperty(json, path.toString(), value);\r\n\t\tsetRootState(root, json);\r\n\t};\r\n\r\n\tconst setRootState = function(root, json){\r\n\t\tlocalStorage.setItem(root, JSON.stringify(json));\r\n\t};\r\n\r\n\tconst getRootState = function(root){\r\n\t\tconst rootJson = localStorage.getItem(root);\r\n\t\tif(rootJson === null){\r\n\t\t\treturn {};\r\n\t\t}\r\n\t\treturn JSON.parse(rootJson);\r\n\t};\r\n\r\n\tluga.namespace(\"luga.string\");\r\n\r\n\t/**\r\n\t * Replace MS Word's non-ISO characters with plausible substitutes\r\n\t *\r\n\t * @param {String} str   String containing MS Word's garbage\r\n\t * @return {String}      The de-moronized string\r\n\t */\r\n\tluga.string.demoronize = function(str){\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(710), \"g\"), \"^\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(732), \"g\"), \"~\");\r\n\t\t// Evil \"smarty\" quotes\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8216), \"g\"), \"'\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8217), \"g\"), \"'\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8220), \"g\"), \"\\\"\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8221), \"g\"), \"\\\"\");\r\n\t\t// More garbage\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8211), \"g\"), \"-\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8212), \"g\"), \"--\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8218), \"g\"), \",\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8222), \"g\"), \",,\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8226), \"g\"), \"*\");\r\n\t\tstr = str.replace(new RegExp(String.fromCharCode(8230), \"g\"), \"...\");\r\n\t\treturn str;\r\n\t};\r\n\r\n\t/**\r\n\t * Given a string containing placeholders, it assembles a new string\r\n\t * replacing the placeholders with the strings contained inside the second argument (either an object or an array)\r\n\t * Loosely based on the .NET implementation: http://msdn.microsoft.com/en-us/library/system.string.format.aspx\r\n\t *\r\n\t * Example passing strings inside an array:\r\n\t * luga.string.format(\"My name is {0} {1}\", [\"Ciccio\", \"Pasticcio\"]);\r\n\t * => \"My name is Ciccio Pasticcio\"\r\n\t *\r\n\t * Example passing strings inside an object:\r\n\t * luga.string.format(\"My name is {firstName} {lastName}\", {firstName: \"Ciccio\", lastName: \"Pasticcio\"});\r\n\t * => \"My name is Ciccio Pasticcio\"\r\n\t *\r\n\t * @param  {String}  str                   String containing placeholders\r\n\t * @param  {Object|Array.<String>} args    Either an array of strings or an objects containing name/value pairs in string format\r\n\t * @return {String} The newly assembled string\r\n\t */\r\n\tluga.string.format = function(str, args){\r\n\t\tlet pattern = null;\r\n\t\tif(Array.isArray(args) === true){\r\n\t\t\tfor(let i = 0; i < args.length; i++){\r\n\t\t\t\tpattern = new RegExp(\"\\\\{\" + i + \"\\\\}\", \"g\");\r\n\t\t\t\tstr = str.replace(pattern, args[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(luga.isPlainObject(args) === true){\r\n\t\t\tfor(let x in args){\r\n\t\t\t\tpattern = new RegExp(\"\\\\{\" + x + \"\\\\}\", \"g\");\r\n\t\t\t\tstr = str.replace(pattern, args[x]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str;\r\n\t};\r\n\r\n\t/**\r\n\t * Given a string in querystring format, return a JavaScript object containing name/value pairs\r\n\t * @param {String} str  The querystring\r\n\t * @return {Object}\r\n\t */\r\n\tluga.string.queryToMap = function(str){\r\n\t\tconst map = {};\r\n\t\tif(str.charAt(0) === \"?\"){\r\n\t\t\tstr = str.substring(1);\r\n\t\t}\r\n\t\tif(str.length === 0){\r\n\t\t\treturn map;\r\n\t\t}\r\n\t\tconst parts = str.split(\"&\");\r\n\r\n\t\tfor(let i = 0; i < parts.length; i++){\r\n\t\t\tconst tokens = parts[i].split(\"=\");\r\n\t\t\tconst fieldName = decodeURIComponent(tokens[0]);\r\n\t\t\tlet fieldValue = \"\";\r\n\t\t\tif(tokens.length === 2){\r\n\t\t\t\tfieldValue = decodeURIComponent(tokens[1]);\r\n\t\t\t}\r\n\t\t\tif(map[fieldName] === undefined){\r\n\t\t\t\tmap[fieldName] = fieldValue;\r\n\t\t\t}\r\n\t\t\telse if(Array.isArray(map[fieldName]) === true){\r\n\t\t\t\tmap[fieldName].push(fieldValue);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tmap[fieldName] = [map[fieldName], fieldValue];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t};\r\n\r\n\tconst propertyPattern = new RegExp(\"\\\\{([^}]*)}\", \"g\");\r\n\r\n\t/**\r\n\t * Given a string containing placeholders in {key} format, it assembles a new string\r\n\t * populating the placeholders with the strings contained inside the second argument keys\r\n\t * Unlike luga.string.format, placeholders can match nested properties too. But it's slower\r\n\t *\r\n\t * Example:\r\n\t * luga.string.format(\"My name is {firstName} {lastName}\", {firstName: \"Ciccio\", lastName: \"Pasticcio\"});\r\n\t * => \"My name is Ciccio Pasticcio\"\r\n\t *\r\n\t * Example with nested properties:\r\n\t * const nestedObj = { type: \"people\", person: { firstName: \"Ciccio\", lastName: \"Pasticcio\" } };\r\n\t * luga.string.populate(\"My name is {person.firstName} {person.lastName}\", nestedObj)\r\n\t * => \"My name is Ciccio Pasticcio\"\r\n\t *\r\n\t * @param  {String} str   String containing placeholders\r\n\t * @param  {Object} obj   An objects containing name/value pairs in string format\r\n\t * @return {String} The newly assembled string\r\n\t */\r\n\tluga.string.populate = function(str, obj){\r\n\t\tif(luga.isPlainObject(obj) === true){\r\n\t\t\tlet results;\r\n\t\t\twhile((results = propertyPattern.exec(str)) !== null){\r\n\t\t\t\tconst property = luga.lookupProperty(obj, results[1]);\r\n\t\t\t\tif(property !== undefined){\r\n\t\t\t\t\tconst pattern = new RegExp(results[0], \"g\");\r\n\t\t\t\t\tstr = str.replace(pattern, property);\r\n\t\t\t\t\t// Keep searching\r\n\t\t\t\t\tpropertyPattern.test(str);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str;\r\n\t};\r\n\r\n\t/* XHR */\r\n\r\n\tluga.namespace(\"luga.xhr\");\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.xhr.header\r\n\t *\r\n\t * @property {String}  name       Name of the HTTP header\r\n\t * @property {String}  value      Value to be used\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.xhr.options\r\n\t *\r\n\t * @property {String}   method                   HTTP method. Default to GET\r\n\t * @property {Function} success                  Function to be invoked if the request succeeds. It will receive a single argument of type luga.xhr.response\r\n\t * @property {Function} error                    Function to be invoked if the request fails. It will receive a single argument of type luga.xhr.response\r\n\t * @property {Number}   timeout                  The number of milliseconds a request can take before automatically being terminated\r\n\t * @property {Boolean}  async                    Indicate that the request should be handled asynchronously. Default to true\r\n\t * @property {Boolean}  cache                    If set to false, it will force requested pages not to be cached by the browser. Will only work correctly with HEAD and GET requests\r\n\t *                                               It works by appending \"_={timestamp}\" to the GET parameters. Default to true\r\n\t * @property {Array.<luga.xhr.header>} headers   An array of name/value pairs to be used for custom HTTP headers. Default to an empty array\r\n\t * @property {String}   requestedWith            Value to be used for the \"X-Requested-With\" request header. Default to \"XMLHttpRequest\"\r\n\t * @property {String}   contentType              MIME type to use instead of the one specified by the server. Default to \"text/plain\"\r\n\t *                                               See also: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/overrideMimeType\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {Object} luga.xhr.response\r\n\t *\r\n\t * @property {Number}       status              Status code returned by the HTTP server\r\n\t * @property {String}       statusText          The response string returned by the HTTP server\r\n\t * @property {String|null}  responseText        The response as text, null if the request was unsuccessful\r\n\t * @property {String}       responseType        A string which specifies what type of data the response contains. See: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType\r\n\t * @property {String|null}  responseXML         The response as text, null if the request was unsuccessful or cannot be parsed as XML or HTML\r\n\t * @property {Array.<luga.xhr.header>} headers  An array of header/value pairs returned by the server\r\n\t */\r\n\r\n\tluga.XHR_CONST = {\r\n\t\tPOST_CONTENT_TYPE: \"application/x-www-form-urlencoded\"\r\n\t};\r\n\r\n\tluga.xhr.Request = function(options){\r\n\t\tconst config = {\r\n\t\t\t/* eslint-disable no-console */\r\n\t\t\tmethod: \"GET\",\r\n\t\t\tsuccess: function(res){\r\n\t\t\t\tconsole.debug(res);\r\n\t\t\t},\r\n\t\t\terror: function(res){\r\n\t\t\t\tconsole.debug(res);\r\n\t\t\t},\r\n\t\t\ttimeout: 5000,\r\n\t\t\tasync: true,\r\n\t\t\tcache: true,\r\n\t\t\theaders: [],\r\n\t\t\trequestedWith: \"XMLHttpRequest\",\r\n\t\t\tcontentType: \"text/plain\"\r\n\t\t};\r\n\t\tif(options !== undefined){\r\n\t\t\tluga.merge(config, options);\r\n\t\t}\r\n\t\tif(config.method.toUpperCase() === \"POST\"){\r\n\t\t\tconfig.contentType = luga.XHR_CONST.POST_CONTENT_TYPE;\r\n\t\t}\r\n\r\n\t\tconst self = this;\r\n\t\tself.xhr = new XMLHttpRequest();\r\n\r\n\t\t/**\r\n\t\t * Turn the string containing HTTP headers into an array of objects\r\n\t\t * @param {String} str\r\n\t\t * @return {Array.<luga.xhr.header>}\r\n\t\t */\r\n\t\tconst headersToArray = function(str){\r\n\t\t\tconst headers = str.split(\"\\r\\n\");\r\n\t\t\t// Remove the last element since it's empty\r\n\t\t\theaders.pop();\r\n\t\t\treturn headers.map(function(item){\r\n\t\t\t\tconst tokens = item.split(\":\");\r\n\t\t\t\tconst ret = {\r\n\t\t\t\t\theader: tokens[0]\r\n\t\t\t\t};\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif(tokens[1] !== undefined){\r\n\t\t\t\t\tret.value = tokens[1].substring(1);\r\n\t\t\t\t}\r\n\t\t\t\treturn ret;\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @return {luga.xhr.response}\r\n\t\t */\r\n\t\tconst assembleResponse = function(){\r\n\t\t\treturn {\r\n\t\t\t\tstatus: self.xhr.status,\r\n\t\t\t\tstatusText: self.xhr.statusText,\r\n\t\t\t\tresponseText: self.xhr.responseText,\r\n\t\t\t\tresponseType: self.xhr.responseType,\r\n\t\t\t\tresponseXML: self.xhr.responseXML,\r\n\t\t\t\theaders: headersToArray(self.xhr.getAllResponseHeaders())\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\tconst checkReadyState = function(){\r\n\t\t\tif(self.xhr.readyState === 4){\r\n\t\t\t\tconst httpStatus = self.xhr.status;\r\n\t\t\t\tif((httpStatus >= 200 && httpStatus <= 300) || (httpStatus === 304)){\r\n\t\t\t\t\tconfig.success(assembleResponse());\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tconfig.error(assembleResponse());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tconst finalizeRequest = function(url){\r\n\t\t\tself.xhr.onreadystatechange = checkReadyState;\r\n\t\t\tself.xhr.timeout = config.timeout;\r\n\t\t\tself.xhr.setRequestHeader(\"Content-Type\", config.contentType);\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(url.substring(0, 4) !== \"http\"){\r\n\t\t\t\t// This may cause issue with CORS so better to avoid on cross-site requests\r\n\t\t\t\tself.xhr.setRequestHeader(\"X-Requested-With\", config.requestedWith);\r\n\t\t\t}\r\n\t\t\tconfig.headers.forEach(function(element){\r\n\t\t\t\tself.xhr.setRequestHeader(element.name, element.value);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tconst finalizeUrl = function(url, params){\r\n\t\t\tlet suffix = \"\";\r\n\t\t\tif(config.cache === false){\r\n\t\t\t\tsuffix += \"_anti-cache=\" + Date.now() + \"&\";\r\n\t\t\t}\r\n\t\t\tif(params !== null && config.method.toUpperCase() === \"GET\"){\r\n\t\t\t\tsuffix += params;\r\n\t\t\t}\r\n\t\t\tif(suffix !== \"\"){\r\n\t\t\t\tif(url.indexOf(\"?\") !== -1){\r\n\t\t\t\t\turl += \"&\";\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\turl += \"?\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn url + suffix;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Aborts the request if it has already been sent\r\n\t\t */\r\n\t\tthis.abort = function(){\r\n\t\t\tself.xhr.abort();\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true if the request is pending. False otherwise\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tthis.isRequestPending = function(){\r\n\t\t\treturn self.xhr.readyState !== 4;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @param {String} url\r\n\t\t * @param {String} [params] Optional parameter which lets you specify the request's body\r\n\t\t *                          See: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send\r\n\t\t */\r\n\t\tthis.send = function(url, params){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(params === undefined){\r\n\t\t\t\tparams = null;\r\n\t\t\t}\r\n\t\t\turl = finalizeUrl(url, params);\r\n\t\t\tself.xhr.open(config.method, url, config.async);\r\n\t\t\tfinalizeRequest(url);\r\n\t\t\tself.xhr.send(params);\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}