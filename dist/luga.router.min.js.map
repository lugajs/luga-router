{"version":3,"sources":["luga.router.min.js","luga.router.js","luga.router.Router.js","luga.router.RouteHandler.js"],"names":["luga","namespace","router","version","isValidRouteHandler","obj","type","path","enter","exit","match","Router","options","CONST","ERROR_MESSAGES","INVALID_ROUTE","DUPLICATE_ROUTE","extend","Notifier","this","config","rootPath","greedy","merge","self","routeHandlers","currentHandlers","add","enterCallBack","exitCallBack","payload","arguments","length","addHandler","route","undefined","getByPath","string","format","push","getAll","i","getMatch","fragment","filter","element","index","array","remove","indexOf","splice","removeAll","resolve","matches","isArray","handlers","forEach","collection","setup","start","window","addEventListener","onHashChange","onPopstate","stop","removeEventListener","location","hash","substring","RouteHandler","enterCallBacks","exitCallBacks","apply"],"mappings":"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","file":"luga.router.min.js","sourcesContent":[null,"/* istanbul ignore if */\r\nif(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.router\");\r\n\tluga.router.version = \"0.1.0\";\r\n\r\n\t/**\r\n\t * Return true if the given object implements the luga.router.iRouteHandler interface. False otherwise\r\n\t * @param {*} obj\r\n\t * @returns {boolean}\r\n\t */\r\n\tluga.router.isValidRouteHandler = function(obj){\r\n\t\tif(luga.type(obj) === \"object\"){\r\n\t\t\tif((luga.type(obj.path) === \"string\") &&\r\n\t\t\t\t(luga.type(obj.enter) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.exit) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.match) === \"function\")){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.options\r\n *\r\n * @property {string} rootPath     Default to empty string\r\n * @property {boolean} greedy      Set it to true to allow multiple routes matching. Default to false\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Router class\r\n\t * @param options {luga.router.options}\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires routeEnter\r\n\t * @fires routeExit\r\n\t */\r\n\tluga.router.Router = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ROUTE: \"luga.router.Router: Invalid route passed to .add() method\",\r\n\t\t\t\tDUPLICATE_ROUTE: \"luga.router.Router: Duplicate route, path {0} already specified\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\trootPath: \"\",\r\n\t\t\tgreedy: false\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t/** @type {luga.router.Router} */\r\n\t\tvar self = this;\r\n\r\n\t\t/** @type {array.<luga.router.iRouteHandler>} */\r\n\t\tvar routeHandlers = [];\r\n\r\n\t\t/** @type {array.<luga.router.iRouteHandler>} */\r\n\t\tvar currentHandlers = [];\r\n\r\n\t\t/**\r\n\t\t * Add a Route. It can be invoked with two different sets of arguments:\r\n\t\t * 1) Only one single Route object:\r\n\t\t * ex: Router.add({luga.router.iRouteHandler})\r\n\t\t *\r\n\t\t *\r\n\t\t * @param {string|luga.router.iRouteHandler} path            Either a Route object or a path expressed as string. Required\r\n\t\t * @param {function|array.<function>} enterCallBack   Either a single callBack function or an array of functions to be invoked before entering the route\r\n\t\t * @param {function|array.<function>} exitCallBack    Either a single callBack function or an array of functions to be invoked before leaving the route. Optional\r\n\t\t * @param {object} payload                            A payload object to be passed to the callBacks. Optional\r\n\t\t */\r\n\t\tthis.add = function(path, enterCallBack, exitCallBack, payload){\r\n\t\t\tif((arguments.length === 1) && (luga.type(arguments[0]) === \"object\")){\r\n\t\t\t\tif(luga.router.isValidRouteHandler(arguments[0]) !== true){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROUTE);\r\n\t\t\t\t}\r\n\t\t\t\taddHandler(arguments[0]);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param {luga.router.iRouteHandler} route\r\n\t\t */\r\n\t\tvar addHandler = function(route){\r\n\t\t\tif(self.getByPath(route.path) !== undefined){\r\n\t\t\t\tthrow(luga.string.format(CONST.ERROR_MESSAGES.DUPLICATE_ROUTE, [route.path]));\r\n\t\t\t}\r\n\t\t\trouteHandlers.push(route);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return all the available route objects\r\n\t\t * @returns {array.<luga.router.iRouteHandler>}\r\n\t\t */\r\n\t\tthis.getAll = function(){\r\n\t\t\treturn routeHandlers;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return a registered route object associated with the given path\r\n\t\t * Return undefined if none is fund\r\n\t\t * @param {string} path\r\n\t\t * @returns {luga.router.iRouteHandler|undefined}\r\n\t\t */\r\n\t\tthis.getByPath = function(path){\r\n\t\t\tfor(var i = 0; i < routeHandlers.length; i++){\r\n\t\t\t\tif(routeHandlers[i].path === path){\r\n\t\t\t\t\treturn routeHandlers[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * If options.greedy is false either:\r\n\t\t * 1) Return a registered routeHandler object matching the given fragment\r\n\t\t * 2) Return undefined if none is fund\r\n\t\t *\r\n\t\t * If options.greedy is true either:\r\n\t\t * 1) Return an array of matching routeHandler objects if options.greedy is true\r\n\t\t * 2) Return an empty array if none is fund\r\n\t\t *\r\n\t\t * @param {string} fragment\r\n\t\t * @returns {luga.router.iRouteHandler|undefined|array.<luga.router.iRouteHandler>}\r\n\t\t */\r\n\t\tthis.getMatch = function(fragment){\r\n\t\t\tif(config.greedy === false){\r\n\t\t\t\tfor(var i = 0; i < routeHandlers.length; i++){\r\n\t\t\t\t\tif(routeHandlers[i].match(fragment) === true){\r\n\t\t\t\t\t\treturn routeHandlers[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\treturn routeHandlers.filter(function(element, index, array){\r\n\t\t\t\t\treturn element.match(fragment) === true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove the routeHandler matching the given path\r\n\t\t * Fails silently if the given path does not match any routeHandler\r\n\t\t * @param {string} path\r\n\t\t */\r\n\t\tthis.remove = function(path){\r\n\t\t\tvar index = routeHandlers.indexOf(self.getByPath(path));\r\n\t\t\tif(index !== -1){\r\n\t\t\t\trouteHandlers.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove all routeHandlers\r\n\t\t */\r\n\t\tthis.removeAll = function(){\r\n\t\t\trouteHandlers = [];\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * If options.greedy is false either fails silently if no match is fund or:\r\n\t\t * 1) Call the exit() method of the previously matched routeHandler\r\n\t\t * 2) Call the enter() method of the first registered routeHandler matching the given fragment\r\n\t\t *\r\n\t\t * If options.greedy is true either fails silently if no match is fund or:\r\n\t\t * 1) Call the exit() method of the previously matched routeHandlers\r\n\t\t * 2) Call the enter() method of all the registered routeHandlers matching the given fragment\r\n\t\t *\r\n\t\t * @param {string} fragment\r\n\t\t */\r\n\t\tthis.resolve = function(fragment){\r\n\t\t\tvar matches = self.getMatch(fragment);\r\n\t\t\tif((luga.isArray(matches) === false) && (luga.type(matches) !== \"undefined\")){\r\n\t\t\t\texit();\r\n\t\t\t\tenter([matches]);\r\n\t\t\t}\r\n\t\t\tif(luga.isArray(matches) === true){\r\n\t\t\t\texit();\r\n\t\t\t\tenter(matches);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Overwrite the current handlers with the given ones\r\n\t\t * Then execute the enter() method on each of them\r\n\t\t * @param {array.<luga.router.iRouteHandler>} handlers\r\n\t\t */\r\n\t\tvar enter = function(handlers){\r\n\t\t\tcurrentHandlers = handlers;\r\n\t\t\tcurrentHandlers.forEach(function(element, i, collection){\r\n\t\t\t\telement.enter();\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute the exit() method on all the current handlers\r\n\t\t */\r\n\t\tvar exit = function(){\r\n\t\t\tcurrentHandlers.forEach(function(element, i, collection){\r\n\t\t\t\telement.exit();\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Change current configuration\r\n\t\t * @param {luga.router.options} options\r\n\t\t * @returns {luga.router.options}\r\n\t\t */\r\n\t\tthis.setup = function(options){\r\n\t\t\tluga.merge(config, options);\r\n\t\t\treturn config;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Bootstrap the Router\r\n\t\t * If inside a browser, start listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.start = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.addEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.addEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop the Router\r\n\t\t * If inside a browser, stop listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.stop = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.removeEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.removeEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.onHashChange = function(){\r\n\t\t\tself.resolve(location.hash.substring(1));\r\n\t\t};\r\n\r\n\t\tthis.onPopstate = function(){\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.iRouteHandler\r\n *\r\n * @property {string} path\r\n * @property {function} enter\r\n * @property {function} exit\r\n * @property {function} match\r\n */\r\n\r\n/**\r\n * @typedef {object} luga.router.iRouteHandler.options\r\n *\r\n * @property {string}           path              Path. Required\r\n * @property {array.<function>} enterCallBacks    Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs\r\n * @property {array.<function>} exitCallBacks     formatter  A formatting functions to be called once for each row in the dataSet. Default to null\r\n * @property {object} payload\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Route class\r\n\t * @param options {luga.router.iRouteHandler.options}\r\n\t * @constructor\r\n\t * @extends luga.router.iRouteHandler\r\n\t */\r\n\tluga.router.RouteHandler = function(options){\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.iRouteHandler.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\tpath: \"\",\r\n\t\t\tenterCallBacks: [],\r\n\t\t\texitCallBacks: [],\r\n\t\t\tpayload: undefined\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t// TODO: turn path into RegExp\r\n\t\tthis.path = config.path;\r\n\r\n\t\t/**\r\n\t\t * Execute registered enter callbacks, if any\r\n\t\t */\r\n\t\tthis.enter = function(){\r\n\t\t\tconfig.enterCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute registered exit callbacks, if any\r\n\t\t */\r\n\t\tthis.exit = function(){\r\n\t\t\tconfig.exitCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true if the given fragment matches the Route. False otherwise\r\n\t\t * @param fragment\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tthis.match = function(fragment){\r\n\t\t\t// TODO: implement pattern matching\r\n\t\t\treturn fragment === config.path;\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}