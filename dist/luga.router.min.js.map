{"version":3,"sources":["luga.router.min.js","luga.router.js","luga.router.Router.js","luga.router.RouteHandler.js"],"names":["luga","namespace","router","version","isValidRouteHandler","obj","type","path","enter","exit","getPayload","match","Router","options","CONST","ERROR_MESSAGES","INVALID_ROUTE","INVALID_ADD_ARGUMENTS","DUPLICATE_ROUTE","EVENTS","ENTER","EXIT","extend","Notifier","this","config","rootPath","handlerConstructor","RouteHandler","greedy","merge","self","routeHandlers","currentFragment","undefined","currentHandlers","add","enterCallBack","exitCallBack","payload","arguments","length","addHandler","enterCallBacks","exitCallBacks","isArray","handler","route","getByPath","string","format","push","getAll","i","getMatch","fragment","filter","element","index","array","normalizeFragment","inputString","pattern","RegExp","replace","normalizeHash","substring","remove","indexOf","splice","removeAll","resolve","matches","handlers","forEach","collection","context","assembleContext","notifyObservers","setup","start","window","addEventListener","onHashChange","onPopstate","stop","removeEventListener","location","hash","event","document","pathname","historyState","state","INVALID_PATH_REGEXP","apply"],"mappings":"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","file":"luga.router.min.js","sourcesContent":[null,"/* istanbul ignore if */\r\nif(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n/**\r\n * @typedef {object} luga.router.IRouteHandler\r\n *\r\n * @property {string} path\r\n * @property {function} enter\r\n * @property {function} exit\r\n * @property {function} getPayload\r\n * @property {function} match\r\n */\r\n\r\n/**\r\n * @typedef {object} luga.router.routeContext\r\n *\r\n * @property {string} fragment                Route fragment. Required\r\n * @property {string} path                    Route path. Required\r\n * @property {object|undefined} payload       Payload associated with the current IRouteHandler. Optional\r\n * @property {object|undefined} historyState  Object associated with a popstate event. Optional\r\n *                                            https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.router\");\r\n\tluga.router.version = \"0.1.0\";\r\n\r\n\t/**\r\n\t * Return true if the given object implements the luga.router.IRouteHandler interface. False otherwise\r\n\t * @param {*} obj\r\n\t * @returns {boolean}\r\n\t */\r\n\tluga.router.isValidRouteHandler = function(obj){\r\n\t\tif(luga.type(obj) === \"object\"){\r\n\t\t\tif((luga.type(obj.path) === \"string\") &&\r\n\t\t\t\t(luga.type(obj.enter) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.exit) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.getPayload) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.match) === \"function\")){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.options\r\n *\r\n * @property {string} rootPath                 Default to empty string\r\n * @property {function} handlerConstructor     Constructor of routeHandler class. Must implement IRouteHandler. Default to luga.router.RouteHandler\r\n * @property {boolean} greedy                  Set it to true to allow multiple routes matching. Default to false\r\n */\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Router class\r\n\t * @param options {luga.router.options}\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires routeEntered\r\n\t * @fires routeExited\r\n\t */\r\n\tluga.router.Router = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ROUTE: \"luga.router.Router: Invalid route passed to .add() method\",\r\n\t\t\t\tINVALID_ADD_ARGUMENTS: \"luga.router.Router: Invalid arguments passed to .add() method\",\r\n\t\t\t\tDUPLICATE_ROUTE: \"luga.router.Router: Duplicate route, path {0} already specified\"\r\n\t\t\t},\r\n\t\t\tEVENTS: {\r\n\t\t\t\tENTER: \"routeEntered\",\r\n\t\t\t\tEXIT: \"routeExited\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\trootPath: \"\",\r\n\t\t\thandlerConstructor: luga.router.RouteHandler,\r\n\t\t\tgreedy: false\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t/** @type {luga.router.Router} */\r\n\t\tvar self = this;\r\n\r\n\t\t/** @type {array.<luga.router.IRouteHandler>} */\r\n\t\tvar routeHandlers = [];\r\n\r\n\t\t/** @type {string|undefined} */\r\n\t\tvar currentFragment = undefined;\r\n\r\n\t\t/** @type {array.<luga.router.IRouteHandler>} */\r\n\t\tvar currentHandlers = [];\r\n\r\n\t\t/**\r\n\t\t * Add a Route. It can be invoked with two different sets of arguments:\r\n\t\t * 1) Only one single Route object:\r\n\t\t * ex: Router.add({luga.router.IRouteHandler})\r\n\t\t *\r\n\t\t *\r\n\t\t * @param {string|luga.router.IRouteHandler} path     Either a Route object or a path expressed as string. Required\r\n\t\t * @param {function|array.<function>} enterCallBack   Either a single callBack function or an array of functions to be invoked before entering the route. Optional\r\n\t\t * @param {function|array.<function>} exitCallBack    Either a single callBack function or an array of functions to be invoked before leaving the route. Optional\r\n\t\t * @param {object} payload                            A payload object to be passed to the callBacks. Optional\r\n\t\t */\r\n\t\tthis.add = function(path, enterCallBack, exitCallBack, payload){\r\n\t\t\tif(arguments.length === 1){\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif((luga.type(arguments[0]) !== \"string\") && (luga.type(arguments[0]) !== \"object\")){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ADD_ARGUMENTS);\r\n\t\t\t\t}\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif(luga.type(arguments[0]) === \"object\"){\r\n\t\t\t\t\tif(luga.router.isValidRouteHandler(arguments[0]) !== true){\r\n\t\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROUTE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\taddHandler(arguments[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif((arguments.length > 1) && (luga.router.isValidRouteHandler(arguments[0]) === true)){\r\n\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ADD_ARGUMENTS);\r\n\t\t\t}\r\n\t\t\tif((arguments.length > 0) && (luga.type(arguments[0]) === \"string\")){\r\n\t\t\t\tvar options = {\r\n\t\t\t\t\tpath: path,\r\n\t\t\t\t\tenterCallBacks: [],\r\n\t\t\t\t\texitCallBacks: [],\r\n\t\t\t\t\tpayload: payload\r\n\t\t\t\t};\r\n\t\t\t\tif(luga.isArray(enterCallBack) === true){\r\n\t\t\t\t\toptions.enterCallBacks = enterCallBack;\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.type(enterCallBack) === \"function\"){\r\n\t\t\t\t\toptions.enterCallBacks = [enterCallBack];\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.isArray(exitCallBack) === true){\r\n\t\t\t\t\toptions.exitCallBacks = exitCallBack;\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.type(exitCallBack) === \"function\"){\r\n\t\t\t\t\toptions.exitCallBacks = [exitCallBack];\r\n\t\t\t\t}\r\n\t\t\t\tvar handler = new config.handlerConstructor(options);\r\n\t\t\t\taddHandler(handler);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param {luga.router.IRouteHandler} route\r\n\t\t */\r\n\t\tvar addHandler = function(route){\r\n\t\t\tif(self.getByPath(route.path) !== undefined){\r\n\t\t\t\tthrow(luga.string.format(CONST.ERROR_MESSAGES.DUPLICATE_ROUTE, [route.path]));\r\n\t\t\t}\r\n\t\t\trouteHandlers.push(route);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return all the available route objects\r\n\t\t * @returns {array.<luga.router.IRouteHandler>}\r\n\t\t */\r\n\t\tthis.getAll = function(){\r\n\t\t\treturn routeHandlers;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return a registered route object associated with the given path\r\n\t\t * Return undefined if none is fund\r\n\t\t * @param {string} path\r\n\t\t * @returns {luga.router.IRouteHandler|undefined}\r\n\t\t */\r\n\t\tthis.getByPath = function(path){\r\n\t\t\tfor(var i = 0; i < routeHandlers.length; i++){\r\n\t\t\t\tif(routeHandlers[i].path === path){\r\n\t\t\t\t\treturn routeHandlers[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * If options.greedy is false either:\r\n\t\t * 1) Return a registered routeHandler object matching the given fragment\r\n\t\t * 2) Return undefined if none is fund\r\n\t\t *\r\n\t\t * If options.greedy is true either:\r\n\t\t * 1) Return an array of matching routeHandler objects if options.greedy is true\r\n\t\t * 2) Return an empty array if none is fund\r\n\t\t *\r\n\t\t * @param {string} fragment\r\n\t\t * @returns {luga.router.IRouteHandler|undefined|array.<luga.router.IRouteHandler>}\r\n\t\t */\r\n\t\tthis.getMatch = function(fragment){\r\n\t\t\tif(config.greedy === false){\r\n\t\t\t\tfor(var i = 0; i < routeHandlers.length; i++){\r\n\t\t\t\t\tif(routeHandlers[i].match(fragment) === true){\r\n\t\t\t\t\t\treturn routeHandlers[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\treturn routeHandlers.filter(function(element, index, array){\r\n\t\t\t\t\treturn element.match(fragment) === true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove the rootPath in front of the given string\r\n\t\t * @param {string} inputString\r\n\t\t * @returns {string}\r\n\t\t */\r\n\t\tthis.normalizeFragment = function(inputString){\r\n\t\t\tvar pattern = new RegExp(\"^\\/?\" + config.rootPath);\r\n\t\t\treturn inputString.replace(pattern, \"\");\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove any '#' and/or '!' in front of the given string\r\n\t\t * @param {string} inputString\r\n\t\t * @returns {string}\r\n\t\t */\r\n\t\tthis.normalizeHash = function(inputString){\r\n\t\t\tif(inputString[0] === \"#\"){\r\n\t\t\t\tinputString = inputString.substring(1);\r\n\t\t\t}\r\n\t\t\tif(inputString[0] === \"!\"){\r\n\t\t\t\tinputString = inputString.substring(1);\r\n\t\t\t}\r\n\t\t\treturn self.normalizeFragment(inputString);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove the routeHandler matching the given path\r\n\t\t * Fails silently if the given path does not match any routeHandler\r\n\t\t * @param {string} path\r\n\t\t */\r\n\t\tthis.remove = function(path){\r\n\t\t\tvar index = routeHandlers.indexOf(self.getByPath(path));\r\n\t\t\tif(index !== -1){\r\n\t\t\t\trouteHandlers.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove all routeHandlers\r\n\t\t */\r\n\t\tthis.removeAll = function(){\r\n\t\t\trouteHandlers = [];\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * If options.greedy is false either fails silently if no match is fund or:\r\n\t\t * 1) Call the exit() method of the previously matched routeHandler\r\n\t\t * 2) Call the enter() method of the first registered routeHandler matching the given fragment\r\n\t\t *\r\n\t\t * If options.greedy is true either fails silently if no match is fund or:\r\n\t\t * 1) Call the exit() method of the previously matched routeHandlers\r\n\t\t * 2) Call the enter() method of all the registered routeHandlers matching the given fragment\r\n\t\t *\r\n\t\t * @param {string} fragment\r\n\t\t * @param {object} options.state\r\n\t\t * @returns {boolean} True if at least one routeHandler was resolved, false otherwise\r\n\t\t */\r\n\t\tthis.resolve = function(fragment, options){\r\n\t\t\tvar matches = self.getMatch(fragment);\r\n\t\t\tif(matches === undefined){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t// Single match\r\n\t\t\tif(luga.isArray(matches) === false){\r\n\t\t\t\tmatches = [matches];\r\n\t\t\t}\r\n\t\t\texit(options);\r\n\t\t\tenter(matches, fragment, options);\r\n\t\t\treturn matches.length > 0;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Overwrite the current handlers with the given ones\r\n\t\t * Then execute the enter() method on each of them\r\n\t\t * Finally: triggers a 'routeEntered' notification\r\n\t\t * @param {array.<luga.router.IRouteHandler>} handlers\r\n\t\t * @param {string} fragment\r\n\t\t * @param {object} options.state\r\n\t\t */\r\n\t\tvar enter = function(handlers, fragment, options){\r\n\t\t\tcurrentHandlers = handlers;\r\n\t\t\tcurrentFragment = fragment;\r\n\t\t\tcurrentHandlers.forEach(function(element, i, collection){\r\n\t\t\t\tvar context = assembleContext(element, fragment, options);\r\n\t\t\t\telement.enter(context);\r\n\t\t\t\tself.notifyObservers(CONST.EVENTS.ENTER, context);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute the exit() method on all the current handlers\r\n\t\t * @param {object} options.state\r\n\t\t */\r\n\t\tvar exit = function(){\r\n\t\t\tcurrentHandlers.forEach(function(element, i, collection){\r\n\t\t\t\tvar context = assembleContext(element, currentFragment, options);\r\n\t\t\t\telement.exit(context);\r\n\t\t\t\tself.notifyObservers(CONST.EVENTS.EXIT, {});\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Assemble a route context\r\n\t\t * @param {luga.router.IRouteHandler} handler\r\n\t\t * @param {string} fragment\r\n\t\t * @param {object} options\r\n\t\t * @returns {luga.router.routeContext}\r\n\t\t */\r\n\t\tvar assembleContext = function(handler, fragment, options){\r\n\t\t\t/** @type {luga.router.routeContext} */\r\n\t\t\tvar context = {\r\n\t\t\t\tfragment: fragment,\r\n\t\t\t\tpath: handler.path\r\n\t\t\t};\r\n\t\t\tif(handler.getPayload() !== undefined){\r\n\t\t\t\tcontext.payload = handler.getPayload();\r\n\t\t\t}\r\n\t\t\tluga.merge(context, options);\r\n\t\t\treturn context;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Change current configuration\r\n\t\t * @param {luga.router.options} options\r\n\t\t * @returns {luga.router.options}\r\n\t\t */\r\n\t\tthis.setup = function(options){\r\n\t\t\tluga.merge(config, options);\r\n\t\t\treturn config;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Bootstrap the Router\r\n\t\t * If inside a browser, start listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.start = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.addEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.addEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop the Router\r\n\t\t * If inside a browser, stop listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.stop = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.removeEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.removeEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Handle a hashchange event\r\n\t\t * https://developer.mozilla.org/en-US/docs/Web/API/HashChangeEvent\r\n\t\t */\r\n\t\tthis.onHashChange = function(){\r\n\t\t\tself.resolve(self.normalizeHash(location.hash));\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Handle a popstate event\r\n\t\t * https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate\r\n\t\t * @param {event} event\r\n\t\t */\r\n\t\tthis.onPopstate = function(event){\r\n\t\t\tvar fragment = self.normalizeFragment(document.location.pathname);\r\n\t\t\tself.resolve(fragment, {historyState: event.state});\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.IRouteHandler.options\r\n *\r\n * @property {string}           path              Path. Required\r\n * @property {array.<function>} enterCallBacks    Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs\r\n * @property {array.<function>} exitCallBacks     formatter  A formatting functions to be called once for each row in the dataSet. Default to null\r\n * @property {object} payload\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Route class\r\n\t * @param options {luga.router.IRouteHandler.options}\r\n\t * @constructor\r\n\t * @extends luga.router.IRouteHandler\r\n\t */\r\n\tluga.router.RouteHandler = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_PATH_REGEXP: \"luga.router.RouteHandler: Invalid path. You must use strings, RegExp are not allowed\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.IRouteHandler.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\tpath: \"\",\r\n\t\t\tenterCallBacks: [],\r\n\t\t\texitCallBacks: [],\r\n\t\t\tpayload: undefined\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\t\tif(luga.type(config.enterCallBacks) === \"function\"){\r\n\t\t\tconfig.enterCallBacks = [config.enterCallBacks];\r\n\t\t}\r\n\t\tif(luga.type(config.exitCallBacks) === \"function\"){\r\n\t\t\tconfig.exitCallBacks = [config.exitCallBacks];\r\n\t\t}\r\n\r\n\t\tif(luga.type(config.path) === \"regexp\"){\r\n\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_PATH_REGEXP);\r\n\t\t}\r\n\r\n\t\t// TODO: compile path\r\n\t\tthis.path = config.path;\r\n\r\n\t\t/**\r\n\t\t * Execute registered enter callbacks, if any\r\n\t\t * @param {luga.router.routeContext} context\r\n\t\t */\r\n\t\tthis.enter = function(context){\r\n\t\t\tconfig.enterCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, [context]);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute registered exit callbacks, if any\r\n\t\t */\r\n\t\tthis.exit = function(){\r\n\t\t\tconfig.exitCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return the handler payload, if any\r\n\t\t * Return undefined if no payload is associated with the handler\r\n\t\t * @returns {luga.router.routeContext|undefined}\r\n\t\t */\r\n\t\tthis.getPayload = function(){\r\n\t\t\treturn config.payload;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true if the given fragment matches the Route. False otherwise\r\n\t\t * @param fragment\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tthis.match = function(fragment){\r\n\t\t\t// TODO: implement pattern matching\r\n\t\t\treturn fragment === config.path;\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}