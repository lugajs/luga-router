{"version":3,"sources":["luga.router.min.js","luga.router.js","luga.router.Router.js","luga.router.RouteHandler.js"],"names":["luga","namespace","router","version","isValidRouteHandler","obj","type","path","enter","exit","match","Router","CONST","ERROR_MESSAGES","INVALID_ROUTE","DUPLICATE_ROUTE","extend","Notifier","this","self","routeHandlers","add","enterCallBack","exitCallBack","payload","arguments","length","addHandler","route","undefined","getHandlerByPath","string","format","push","getAllHandlers","find","element","index","array","start","window","addEventListener","onHashChange","onPopstate","stop","removeEventListener","RouteHandler","options","config","enterCallBacks","exitCallBacks","merge","forEach","i","collection","apply","fragment"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,ACJA,GAAA,mBAAA,MACA,KAAA,+BAGA,WACA,YAEAA,MAAAC,UAAA,eACAD,KAAAE,OAAAC,QAAA,QAOAH,KAAAE,OAAAE,oBAAA,SAAAC,KACA,MAAA,WAAAL,KAAAM,KAAAD,MACA,WAAAL,KAAAM,KAAAD,IAAAE,OACA,aAAAP,KAAAM,KAAAD,IAAAG,QACA,aAAAR,KAAAM,KAAAD,IAAAI,OACA,aAAAT,KAAAM,KAAAD,IAAAK,QACA,GAGA,MCzBA,WACA,YASAV,MAAAE,OAAAS,OAAA,WAEA,GAAAC,QACAC,gBACAC,cAAA,4DACAC,gBAAA,mEAIAf,MAAAgB,OAAAhB,KAAAiB,SAAAC,KAGA,IAAAC,MAAAD,KAGAE,gBAaAF,MAAAG,IAAA,SAAAd,KAAAe,cAAAC,aAAAC,SACA,GAAA,IAAAC,UAAAC,QAAA,WAAA1B,KAAAM,KAAAmB,UAAA,IAAA,CACA,GAAAzB,KAAAE,OAAAE,oBAAAqB,UAAA,OAAA,EACA,KAAAb,OAAAC,eAAA,aAEAc,YAAAF,UAAA,KAQA,IAAAE,YAAA,SAAAC,OACA,GAAAC,SAAAV,KAAAW,iBAAAF,MAAArB,MACA,KAAAP,MAAA+B,OAAAC,OAAApB,MAAAC,eAAAE,iBAAAa,MAAArB,MAEAa,eAAAa,KAAAL,OAOAV,MAAAgB,eAAA,WACA,MAAAd,gBASAF,KAAAY,iBAAA,SAAAvB,MACA,MAAAa,eAAAe,KAAA,SAAAC,QAAAC,MAAAC,OACA,MAAAF,SAAA7B,OAAAA,QAQAW,KAAAqB,MAAA,WAEAV,SAAAW,SACAA,OAAAC,iBAAA,aAAAtB,KAAAuB,cAAA,GACAF,OAAAC,iBAAA,WAAAtB,KAAAwB,YAAA,KAQAzB,KAAA0B,KAAA,WAEAf,SAAAW,SACAA,OAAAK,oBAAA,aAAA1B,KAAAuB,cAAA,GACAF,OAAAK,oBAAA,WAAA1B,KAAAwB,YAAA,KAIAzB,KAAAwB,aAAA,aAIAxB,KAAAyB,WAAA,iBCxFA,WACA,YAQA3C,MAAAE,OAAA4C,aAAA,SAAAC,SAKA,GAAAC,SACAzC,KAAA,GACA0C,kBACAC,iBACA1B,QAAAK,OAGA7B,MAAAmD,MAAAH,OAAAD,QAMA7B,MAAAX,KAAAyC,OAAAzC,KAKAW,KAAAV,MAAA,WACAwC,OAAAC,eAAAG,QAAA,SAAAhB,QAAAiB,EAAAC,YACAlB,QAAAmB,MAAA,YAOArC,KAAAT,KAAA,WACAuC,OAAAE,cAAAE,QAAA,SAAAhB,QAAAiB,EAAAC,YACAlB,QAAAmB,MAAA,YASArC,KAAAR,MAAA,SAAA8C,UAEA,MAAAA,YAAAR,OAAAzC","file":"luga.router.min.js","sourcesContent":[null,"/* istanbul ignore if */\r\nif(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.router\");\r\n\tluga.router.version = \"0.1.0\";\r\n\r\n\t/**\r\n\t * Return true if the given object implements the luga.router.iRouteHandler interface. False otherwise\r\n\t * @param {*} obj\r\n\t * @returns {boolean}\r\n\t */\r\n\tluga.router.isValidRouteHandler = function(obj){\r\n\t\tif(luga.type(obj) === \"object\"){\r\n\t\t\tif((luga.type(obj.path) === \"string\") &&\r\n\t\t\t\t(luga.type(obj.enter) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.exit) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.match) === \"function\")){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Router class\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires routeEnter\r\n\t * @fires routeExit\r\n\t */\r\n\tluga.router.Router = function(){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ROUTE: \"luga.router.Router: Invalid route passed to .add() method\",\r\n\t\t\t\tDUPLICATE_ROUTE: \"luga.router.Router: Duplicate route, path {0} already specified\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/** @type {luga.router.Router} */\r\n\t\tvar self = this;\r\n\r\n\t\t/** @type {array.<luga.router.iRouteHandler>} */\r\n\t\tvar routeHandlers = [];\r\n\r\n\t\t/**\r\n\t\t * Add a Route. It can be invoked with two different sets of arguments:\r\n\t\t * 1) Only one single Route object:\r\n\t\t * ex: Router.add({luga.router.iRouteHandler})\r\n\t\t *\r\n\t\t *\r\n\t\t * @param {string|luga.router.iRouteHandler} path            Either a Route object or a path expressed as string. Required\r\n\t\t * @param {function|array.<function>} enterCallBack   Either a single callBack function or an array of functions to be invoked before entering the route\r\n\t\t * @param {function|array.<function>} exitCallBack    Either a single callBack function or an array of functions to be invoked before leaving the route. Optional\r\n\t\t * @param {object} payload                            A payload object to be passed to the callBacks. Optional\r\n\t\t */\r\n\t\tthis.add = function(path, enterCallBack, exitCallBack, payload){\r\n\t\t\tif((arguments.length === 1) && (luga.type(arguments[0]) === \"object\")){\r\n\t\t\t\tif(luga.router.isValidRouteHandler(arguments[0]) !== true){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROUTE);\r\n\t\t\t\t}\r\n\t\t\t\taddHandler(arguments[0]);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param {luga.router.iRouteHandler} route\r\n\t\t */\r\n\t\tvar addHandler = function(route){\r\n\t\t\tif(self.getHandlerByPath(route.path) !== undefined){\r\n\t\t\t\tthrow(luga.string.format(CONST.ERROR_MESSAGES.DUPLICATE_ROUTE, [route.path]));\r\n\t\t\t}\r\n\t\t\trouteHandlers.push(route);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return all the available route objects\r\n\t\t * @returns {array.<luga.router.iRouteHandler>}\r\n\t\t */\r\n\t\tthis.getAllHandlers = function(){\r\n\t\t\treturn routeHandlers;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return a registered route object associated with the given path\r\n\t\t * Return undefined if none is fund\r\n\t\t * @param {string} path\r\n\t\t * @returns {luga.router.iRouteHandler|undefined}\r\n\t\t */\r\n\t\tthis.getHandlerByPath = function(path){\r\n\t\t\treturn routeHandlers.find(function(element, index, array){\r\n\t\t\t\treturn element.path === path;\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Bootstrap the Router\r\n\t\t * If inside a browser, start listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.start = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.addEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.addEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop the Router\r\n\t\t * If inside a browser, stop listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.stop = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.removeEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.removeEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.onHashChange = function(){\r\n\r\n\t\t};\r\n\r\n\t\tthis.onPopstate = function(){\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.iRouteHandler\r\n *\r\n * @property {string} path\r\n * @property {function} enter\r\n * @property {function} exit\r\n * @property {function} match\r\n */\r\n\r\n/**\r\n * @typedef {object} luga.router.iRouteHandler.options\r\n *\r\n * @property {string}           path              Path. Required\r\n * @property {array.<function>} enterCallBacks    Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs\r\n * @property {array.<function>} exitCallBacks     formatter  A formatting functions to be called once for each row in the dataSet. Default to null\r\n * @property {object} payload\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Route class\r\n\t * @param options {luga.router.iRouteHandler.options}\r\n\t * @constructor\r\n\t * @extends luga.router.iRouteHandler\r\n\t */\r\n\tluga.router.RouteHandler = function(options){\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.iRouteHandler.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\tpath: \"\",\r\n\t\t\tenterCallBacks: [],\r\n\t\t\texitCallBacks: [],\r\n\t\t\tpayload: undefined\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t/** @type {luga.router.RouteHandler} */\r\n\t\tvar self = this;\r\n\r\n\t\t// TODO: turn path into RegExp\r\n\t\tthis.path = config.path;\r\n\r\n\t\t/**\r\n\t\t * Execute registered enter callbacks, if any\r\n\t\t */\r\n\t\tthis.enter = function(){\r\n\t\t\tconfig.enterCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute registered exit callbacks, if any\r\n\t\t */\r\n\t\tthis.exit = function(){\r\n\t\t\tconfig.exitCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true if the given fragment matches the Route. False otherwise\r\n\t\t * @param fragment\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tthis.match = function(fragment){\r\n\t\t\t// TODO: implement pattern matching\r\n\t\t\treturn fragment === config.path;\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}