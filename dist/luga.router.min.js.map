{"version":3,"sources":["luga.router.min.js","luga.router.js","luga.router.Router.js","luga.router.RouteHandler.js"],"names":["luga","namespace","router","version","isValidRouteHandler","obj","type","path","enter","exit","match","Router","options","CONST","ERROR_MESSAGES","INVALID_ROUTE","DUPLICATE_ROUTE","extend","Notifier","this","config","rootPath","greedy","merge","self","routeHandlers","add","enterCallBack","exitCallBack","payload","arguments","length","addHandler","route","undefined","getHandlerByPath","string","format","push","getAllHandlers","find","element","index","array","getMatchingHandler","fragment","filter","setup","start","window","addEventListener","onHashChange","onPopstate","stop","removeEventListener","RouteHandler","enterCallBacks","exitCallBacks","forEach","i","collection","apply"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,ACJA,GAAA,mBAAA,MACA,KAAA,+BAGA,WACA,YAEAA,MAAAC,UAAA,eACAD,KAAAE,OAAAC,QAAA,QAOAH,KAAAE,OAAAE,oBAAA,SAAAC,KACA,MAAA,WAAAL,KAAAM,KAAAD,MACA,WAAAL,KAAAM,KAAAD,IAAAE,OACA,aAAAP,KAAAM,KAAAD,IAAAG,QACA,aAAAR,KAAAM,KAAAD,IAAAI,OACA,aAAAT,KAAAM,KAAAD,IAAAK,QACA,GAGA,MClBA,WACA,YAUAV,MAAAE,OAAAS,OAAA,SAAAC,SAEA,GAAAC,QACAC,gBACAC,cAAA,4DACAC,gBAAA,mEAIAhB,MAAAiB,OAAAjB,KAAAkB,SAAAC,KAKA,IAAAC,SACAC,SAAA,GACAC,QAAA,EAGAtB,MAAAuB,MAAAH,OAAAR,QAGA,IAAAY,MAAAL,KAGAM,gBAgBAN,MAAAO,IAAA,SAAAnB,KAAAoB,cAAAC,aAAAC,SACA,GAAA,IAAAC,UAAAC,QAAA,WAAA/B,KAAAM,KAAAwB,UAAA,IAAA,CACA,GAAA9B,KAAAE,OAAAE,oBAAA0B,UAAA,OAAA,EACA,KAAAjB,OAAAC,eAAA,aAEAkB,YAAAF,UAAA,KAQA,IAAAE,YAAA,SAAAC,OACA,GAAAC,SAAAV,KAAAW,iBAAAF,MAAA1B,MACA,KAAAP,MAAAoC,OAAAC,OAAAxB,MAAAC,eAAAE,iBAAAiB,MAAA1B,MAEAkB,eAAAa,KAAAL,OAOAd,MAAAoB,eAAA,WACA,MAAAd,gBASAN,KAAAgB,iBAAA,SAAA5B,MACA,MAAAkB,eAAAe,KAAA,SAAAC,QAAAC,MAAAC,OACA,MAAAF,SAAAlC,OAAAA,QAUAY,KAAAyB,mBAAA,SAAAC,UACA,MAAAzB,QAAAE,UAAA,EACAG,cAAAe,KAAA,SAAAC,QAAAC,MAAAC,OACA,MAAAF,SAAA/B,MAAAmC,aAAA,IAIApB,cAAAqB,OAAA,SAAAL,QAAAC,MAAAC,OACA,MAAAF,SAAA/B,MAAAmC,aAAA,KAUA1B,KAAA4B,MAAA,SAAAnC,SAEA,MADAZ,MAAAuB,MAAAH,OAAAR,SACAQ,QAOAD,KAAA6B,MAAA,WAEAd,SAAAe,SACAA,OAAAC,iBAAA,aAAA1B,KAAA2B,cAAA,GACAF,OAAAC,iBAAA,WAAA1B,KAAA4B,YAAA,KAQAjC,KAAAkC,KAAA,WAEAnB,SAAAe,SACAA,OAAAK,oBAAA,aAAA9B,KAAA2B,cAAA,GACAF,OAAAK,oBAAA,WAAA9B,KAAA4B,YAAA,KAIAjC,KAAAgC,aAAA,aAIAhC,KAAAiC,WAAA,iBC1IA,WACA,YAQApD,MAAAE,OAAAqD,aAAA,SAAA3C,SAKA,GAAAQ,SACAb,KAAA,GACAiD,kBACAC,iBACA5B,QAAAK,OAGAlC,MAAAuB,MAAAH,OAAAR,QAMAO,MAAAZ,KAAAa,OAAAb,KAKAY,KAAAX,MAAA,WACAY,OAAAoC,eAAAE,QAAA,SAAAjB,QAAAkB,EAAAC,YACAnB,QAAAoB,MAAA,YAOA1C,KAAAV,KAAA,WACAW,OAAAqC,cAAAC,QAAA,SAAAjB,QAAAkB,EAAAC,YACAnB,QAAAoB,MAAA,YASA1C,KAAAT,MAAA,SAAAmC,UAEA,MAAAA,YAAAzB,OAAAb","file":"luga.router.min.js","sourcesContent":[null,"/* istanbul ignore if */\r\nif(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.router\");\r\n\tluga.router.version = \"0.1.0\";\r\n\r\n\t/**\r\n\t * Return true if the given object implements the luga.router.iRouteHandler interface. False otherwise\r\n\t * @param {*} obj\r\n\t * @returns {boolean}\r\n\t */\r\n\tluga.router.isValidRouteHandler = function(obj){\r\n\t\tif(luga.type(obj) === \"object\"){\r\n\t\t\tif((luga.type(obj.path) === \"string\") &&\r\n\t\t\t\t(luga.type(obj.enter) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.exit) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.match) === \"function\")){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.options\r\n *\r\n * @property {string} rootPath     Default to empty string\r\n * @property {boolean} greedy      Set it to true to allow multiple routes matching. Default to false\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Router class\r\n\t * @param options {luga.router.options}\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires routeEnter\r\n\t * @fires routeExit\r\n\t */\r\n\tluga.router.Router = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ROUTE: \"luga.router.Router: Invalid route passed to .add() method\",\r\n\t\t\t\tDUPLICATE_ROUTE: \"luga.router.Router: Duplicate route, path {0} already specified\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\trootPath: \"\",\r\n\t\t\tgreedy: false\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t/** @type {luga.router.Router} */\r\n\t\tvar self = this;\r\n\r\n\t\t/** @type {array.<luga.router.iRouteHandler>} */\r\n\t\tvar routeHandlers = [];\r\n\r\n\t\t/** @type {array.<luga.router.iRouteHandler>} */\r\n\t\tvar currentHandlers = [];\r\n\r\n\t\t/**\r\n\t\t * Add a Route. It can be invoked with two different sets of arguments:\r\n\t\t * 1) Only one single Route object:\r\n\t\t * ex: Router.add({luga.router.iRouteHandler})\r\n\t\t *\r\n\t\t *\r\n\t\t * @param {string|luga.router.iRouteHandler} path            Either a Route object or a path expressed as string. Required\r\n\t\t * @param {function|array.<function>} enterCallBack   Either a single callBack function or an array of functions to be invoked before entering the route\r\n\t\t * @param {function|array.<function>} exitCallBack    Either a single callBack function or an array of functions to be invoked before leaving the route. Optional\r\n\t\t * @param {object} payload                            A payload object to be passed to the callBacks. Optional\r\n\t\t */\r\n\t\tthis.add = function(path, enterCallBack, exitCallBack, payload){\r\n\t\t\tif((arguments.length === 1) && (luga.type(arguments[0]) === \"object\")){\r\n\t\t\t\tif(luga.router.isValidRouteHandler(arguments[0]) !== true){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROUTE);\r\n\t\t\t\t}\r\n\t\t\t\taddHandler(arguments[0]);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param {luga.router.iRouteHandler} route\r\n\t\t */\r\n\t\tvar addHandler = function(route){\r\n\t\t\tif(self.getHandlerByPath(route.path) !== undefined){\r\n\t\t\t\tthrow(luga.string.format(CONST.ERROR_MESSAGES.DUPLICATE_ROUTE, [route.path]));\r\n\t\t\t}\r\n\t\t\trouteHandlers.push(route);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return all the available route objects\r\n\t\t * @returns {array.<luga.router.iRouteHandler>}\r\n\t\t */\r\n\t\tthis.getAllHandlers = function(){\r\n\t\t\treturn routeHandlers;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return a registered route object associated with the given path\r\n\t\t * Return undefined if none is fund\r\n\t\t * @param {string} path\r\n\t\t * @returns {luga.router.iRouteHandler|undefined}\r\n\t\t */\r\n\t\tthis.getHandlerByPath = function(path){\r\n\t\t\treturn routeHandlers.find(function(element, index, array){\r\n\t\t\t\treturn element.path === path;\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return a registered route object matching the given fragment\r\n\t\t * Return undefined if none is fund\r\n\t\t * @param {string} fragment\r\n\t\t * @returns {luga.router.iRouteHandler|undefined|array.<luga.router.iRouteHandler>}\r\n\t\t */\r\n\t\tthis.getMatchingHandler = function(fragment){\r\n\t\t\tif(config.greedy === false){\r\n\t\t\t\treturn routeHandlers.find(function(element, index, array){\r\n\t\t\t\t\treturn element.match(fragment) === true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\treturn routeHandlers.filter(function(element, index, array){\r\n\t\t\t\t\treturn element.match(fragment) === true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Change current configuration\r\n\t\t * @param {luga.router.options} options\r\n\t\t * @returns {luga.router.options}\r\n\t\t */\r\n\t\tthis.setup = function(options){\r\n\t\t\tluga.merge(config, options);\r\n\t\t\treturn config;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Bootstrap the Router\r\n\t\t * If inside a browser, start listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.start = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.addEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.addEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop the Router\r\n\t\t * If inside a browser, stop listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.stop = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.removeEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.removeEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.onHashChange = function(){\r\n\r\n\t\t};\r\n\r\n\t\tthis.onPopstate = function(){\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.iRouteHandler\r\n *\r\n * @property {string} path\r\n * @property {function} enter\r\n * @property {function} exit\r\n * @property {function} match\r\n */\r\n\r\n/**\r\n * @typedef {object} luga.router.iRouteHandler.options\r\n *\r\n * @property {string}           path              Path. Required\r\n * @property {array.<function>} enterCallBacks    Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs\r\n * @property {array.<function>} exitCallBacks     formatter  A formatting functions to be called once for each row in the dataSet. Default to null\r\n * @property {object} payload\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Route class\r\n\t * @param options {luga.router.iRouteHandler.options}\r\n\t * @constructor\r\n\t * @extends luga.router.iRouteHandler\r\n\t */\r\n\tluga.router.RouteHandler = function(options){\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.iRouteHandler.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\tpath: \"\",\r\n\t\t\tenterCallBacks: [],\r\n\t\t\texitCallBacks: [],\r\n\t\t\tpayload: undefined\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t/** @type {luga.router.RouteHandler} */\r\n\t\tvar self = this;\r\n\r\n\t\t// TODO: turn path into RegExp\r\n\t\tthis.path = config.path;\r\n\r\n\t\t/**\r\n\t\t * Execute registered enter callbacks, if any\r\n\t\t */\r\n\t\tthis.enter = function(){\r\n\t\t\tconfig.enterCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute registered exit callbacks, if any\r\n\t\t */\r\n\t\tthis.exit = function(){\r\n\t\t\tconfig.exitCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true if the given fragment matches the Route. False otherwise\r\n\t\t * @param fragment\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tthis.match = function(fragment){\r\n\t\t\t// TODO: implement pattern matching\r\n\t\t\treturn fragment === config.path;\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}