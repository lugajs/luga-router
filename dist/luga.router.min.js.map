{"version":3,"sources":["luga.router.min.js","luga.router.js","luga.router.Router.js","luga.router.Route.js"],"names":["luga","namespace","router","version","Router","extend","Notifier","this","self","start","undefined","window","addEventListener","onHashChange","onPopstate","stop","removeEventListener","Route","options","config","path","enterCallBacks","exitCallBacks","merge","enter","forEach","element","i","collection","call","exit","match","fragment"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,ACJA,GAAA,mBAAA,MACA,KAAA,+BAGA,WACA,YAEAA,MAAAC,UAAA,eACAD,KAAAE,OAAAC,QAAA,WCTA,WACA,YAQAH,MAAAE,OAAAE,OAAA,WAEAJ,KAAAK,OAAAL,KAAAM,SAAAC,KAGA,IAAAC,MAAAD,IAMAA,MAAAE,MAAA,WAEAC,SAAAC,SACAA,OAAAC,iBAAA,aAAAJ,KAAAK,cAAA,GACAF,OAAAC,iBAAA,WAAAJ,KAAAM,YAAA,KAQAP,KAAAQ,KAAA,WAEAL,SAAAC,SACAA,OAAAK,oBAAA,aAAAR,KAAAK,cAAA,GACAF,OAAAK,oBAAA,WAAAR,KAAAM,YAAA,KAIAP,KAAAM,aAAA,aAIAN,KAAAO,WAAA,iBC3BA,WACA,YAQAd,MAAAE,OAAAe,MAAA,SAAAC,SAKA,GAAAC,SACAC,KAAA,GACAC,kBACAC,iBAGAtB,MAAAuB,MAAAJ,OAAAD,QAKAX,MAAAa,KAAAD,OAAAC,KAKAb,KAAAiB,MAAA,WACAL,OAAAE,eAAAI,QAAA,SAAAC,QAAAC,EAAAC,YACAF,QAAAG,UAOAtB,KAAAuB,KAAA,WACAX,OAAAG,cAAAG,QAAA,SAAAC,QAAAC,EAAAC,YACAF,QAAAG,UASAtB,KAAAwB,MAAA,SAAAC,UAEA,MAAAA,YAAAb,OAAAC","file":"luga.router.min.js","sourcesContent":[null,"/* istanbul ignore if */\r\nif(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.router\");\r\n\tluga.router.version = \"0.1.0\";\r\n\r\n}());","(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Router class\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires routeChanged\r\n\t */\r\n\tluga.router.Router = function(){\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/** @type {luga.router.Router} */\r\n\t\tvar self = this;\r\n\r\n\t\t/**\r\n\t\t * Bootstrap the Router\r\n\t\t * If inside a browser, start listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.start = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.addEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.addEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop the Router\r\n\t\t * If inside a browser, stop listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.stop = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.removeEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.removeEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.onHashChange = function(){\r\n\r\n\t\t};\r\n\r\n\t\tthis.onPopstate = function(){\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.iRoute\r\n *\r\n * @property {string} path\r\n * @property {function} enter\r\n * @property {function} exit\r\n * @property {function} match\r\n */\r\n\r\n/**\r\n * @typedef {object} luga.router.iRoute.options\r\n *\r\n * @property {string}           path              Path. Required\r\n * @property {array.<function>} enterCallBacks    Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs\r\n * @property {array.<function>} exitCallBacks     formatter  A formatting functions to be called once for each row in the dataSet. Default to null\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Route class\r\n\t * @param options {luga.router.iRoute.options}\r\n\t * @constructor\r\n\t * @extends luga.router.iRoute\r\n\t */\r\n\tluga.router.Route = function(options){\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.iRoute.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\tpath: \"\",\r\n\t\t\tenterCallBacks: [],\r\n\t\t\texitCallBacks: []\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t/** @type {luga.router.iRoute} */\r\n\t\tvar self = this;\r\n\r\n\t\tthis.path = config.path;\r\n\r\n\t\t/**\r\n\t\t * Execute registered exit callbacks, if any\r\n\t\t */\r\n\t\tthis.enter = function(){\r\n\t\t\tconfig.enterCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.call();\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute registered exit callbacks, if any\r\n\t\t */\r\n\t\tthis.exit = function(){\r\n\t\t\tconfig.exitCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.call();\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true if the given fragment matches the Route. False otherwise\r\n\t\t * @param fragment\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tthis.match = function(fragment){\r\n\t\t\t// TODO: implement pattern matching\r\n\t\t\treturn fragment === config.path;\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}