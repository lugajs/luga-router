{"version":3,"sources":["luga.router.min.js","luga.router.js","luga.router.Router.js","luga.router.RouteHandler.js"],"names":["luga","namespace","router","version","isValidRouteHandler","obj","type","path","enter","exit","match","Router","options","CONST","ERROR_MESSAGES","INVALID_ROUTE","DUPLICATE_ROUTE","extend","Notifier","this","config","rootPath","greedy","merge","self","routeHandlers","currentHandlers","add","enterCallBack","exitCallBack","payload","arguments","length","addHandler","enterCallBacks","exitCallBacks","isArray","handler","RouteHandler","route","undefined","getByPath","string","format","push","getAll","i","getMatch","fragment","filter","element","index","array","remove","indexOf","splice","removeAll","resolve","matches","context","handlers","forEach","collection","setup","start","window","addEventListener","onHashChange","onPopstate","stop","removeEventListener","location","hash","substring","apply"],"mappings":"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","file":"luga.router.min.js","sourcesContent":[null,"/* istanbul ignore if */\r\nif(typeof(luga) === \"undefined\"){\r\n\tthrow(\"Unable to find Luga JS Core\");\r\n}\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\tluga.namespace(\"luga.router\");\r\n\tluga.router.version = \"0.1.0\";\r\n\r\n\t/**\r\n\t * Return true if the given object implements the luga.router.iRouteHandler interface. False otherwise\r\n\t * @param {*} obj\r\n\t * @returns {boolean}\r\n\t */\r\n\tluga.router.isValidRouteHandler = function(obj){\r\n\t\tif(luga.type(obj) === \"object\"){\r\n\t\t\tif((luga.type(obj.path) === \"string\") &&\r\n\t\t\t\t(luga.type(obj.enter) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.exit) === \"function\") &&\r\n\t\t\t\t(luga.type(obj.match) === \"function\")){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.options\r\n *\r\n * @property {string} rootPath     Default to empty string\r\n * @property {boolean} greedy      Set it to true to allow multiple routes matching. Default to false\r\n */\r\n\r\n/**\r\n * @typedef {object} luga.router.routeContext\r\n *\r\n * @property {string} fragment   Route fragment\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Router class\r\n\t * @param options {luga.router.options}\r\n\t * @constructor\r\n\t * @extends luga.Notifier\r\n\t * @fires routeEnter\r\n\t * @fires routeExit\r\n\t */\r\n\tluga.router.Router = function(options){\r\n\r\n\t\tvar CONST = {\r\n\t\t\tERROR_MESSAGES: {\r\n\t\t\t\tINVALID_ROUTE: \"luga.router.Router: Invalid route passed to .add() method\",\r\n\t\t\t\tDUPLICATE_ROUTE: \"luga.router.Router: Duplicate route, path {0} already specified\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tluga.extend(luga.Notifier, this);\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\trootPath: \"\",\r\n\t\t\tgreedy: false\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t/** @type {luga.router.Router} */\r\n\t\tvar self = this;\r\n\r\n\t\t/** @type {array.<luga.router.iRouteHandler>} */\r\n\t\tvar routeHandlers = [];\r\n\r\n\t\t/** @type {array.<luga.router.iRouteHandler>} */\r\n\t\tvar currentHandlers = [];\r\n\r\n\t\t/**\r\n\t\t * Add a Route. It can be invoked with two different sets of arguments:\r\n\t\t * 1) Only one single Route object:\r\n\t\t * ex: Router.add({luga.router.iRouteHandler})\r\n\t\t *\r\n\t\t *\r\n\t\t * @param {string|luga.router.iRouteHandler} path            Either a Route object or a path expressed as string. Required\r\n\t\t * @param {function|array.<function>} enterCallBack   Either a single callBack function or an array of functions to be invoked before entering the route. Optional\r\n\t\t * @param {function|array.<function>} exitCallBack    Either a single callBack function or an array of functions to be invoked before leaving the route. Optional\r\n\t\t * @param {object} payload                            A payload object to be passed to the callBacks. Optional\r\n\t\t */\r\n\t\tthis.add = function(path, enterCallBack, exitCallBack, payload){\r\n\t\t\tif((arguments.length === 1) && (luga.type(arguments[0]) === \"object\")){\r\n\t\t\t\tif(luga.router.isValidRouteHandler(arguments[0]) !== true){\r\n\t\t\t\t\tthrow(CONST.ERROR_MESSAGES.INVALID_ROUTE);\r\n\t\t\t\t}\r\n\t\t\t\taddHandler(arguments[0]);\r\n\t\t\t}\r\n\t\t\tif((arguments.length > 0) && (luga.type(arguments[0]) === \"string\")){\r\n\t\t\t\tvar options = {\r\n\t\t\t\t\tpath: path,\r\n\t\t\t\t\tenterCallBacks: [],\r\n\t\t\t\t\texitCallBacks: [],\r\n\t\t\t\t\tpayload: payload\r\n\t\t\t\t};\r\n\t\t\t\tif(luga.isArray(enterCallBack) === true){\r\n\t\t\t\t\toptions.enterCallBacks = enterCallBack;\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.type(enterCallBack) === \"function\"){\r\n\t\t\t\t\toptions.enterCallBacks = [enterCallBack];\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.isArray(exitCallBack) === true){\r\n\t\t\t\t\toptions.enterCallBacks = exitCallBack;\r\n\t\t\t\t}\r\n\t\t\t\tif(luga.type(exitCallBack) === \"function\"){\r\n\t\t\t\t\toptions.exitCallBacks = [exitCallBack];\r\n\t\t\t\t}\r\n\t\t\t\tvar handler = new luga.router.RouteHandler(options);\r\n\t\t\t\taddHandler(handler);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param {luga.router.iRouteHandler} route\r\n\t\t */\r\n\t\tvar addHandler = function(route){\r\n\t\t\tif(self.getByPath(route.path) !== undefined){\r\n\t\t\t\tthrow(luga.string.format(CONST.ERROR_MESSAGES.DUPLICATE_ROUTE, [route.path]));\r\n\t\t\t}\r\n\t\t\trouteHandlers.push(route);\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return all the available route objects\r\n\t\t * @returns {array.<luga.router.iRouteHandler>}\r\n\t\t */\r\n\t\tthis.getAll = function(){\r\n\t\t\treturn routeHandlers;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return a registered route object associated with the given path\r\n\t\t * Return undefined if none is fund\r\n\t\t * @param {string} path\r\n\t\t * @returns {luga.router.iRouteHandler|undefined}\r\n\t\t */\r\n\t\tthis.getByPath = function(path){\r\n\t\t\tfor(var i = 0; i < routeHandlers.length; i++){\r\n\t\t\t\tif(routeHandlers[i].path === path){\r\n\t\t\t\t\treturn routeHandlers[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * If options.greedy is false either:\r\n\t\t * 1) Return a registered routeHandler object matching the given fragment\r\n\t\t * 2) Return undefined if none is fund\r\n\t\t *\r\n\t\t * If options.greedy is true either:\r\n\t\t * 1) Return an array of matching routeHandler objects if options.greedy is true\r\n\t\t * 2) Return an empty array if none is fund\r\n\t\t *\r\n\t\t * @param {string} fragment\r\n\t\t * @returns {luga.router.iRouteHandler|undefined|array.<luga.router.iRouteHandler>}\r\n\t\t */\r\n\t\tthis.getMatch = function(fragment){\r\n\t\t\tif(config.greedy === false){\r\n\t\t\t\tfor(var i = 0; i < routeHandlers.length; i++){\r\n\t\t\t\t\tif(routeHandlers[i].match(fragment) === true){\r\n\t\t\t\t\t\treturn routeHandlers[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\treturn routeHandlers.filter(function(element, index, array){\r\n\t\t\t\t\treturn element.match(fragment) === true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove the routeHandler matching the given path\r\n\t\t * Fails silently if the given path does not match any routeHandler\r\n\t\t * @param {string} path\r\n\t\t */\r\n\t\tthis.remove = function(path){\r\n\t\t\tvar index = routeHandlers.indexOf(self.getByPath(path));\r\n\t\t\tif(index !== -1){\r\n\t\t\t\trouteHandlers.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Remove all routeHandlers\r\n\t\t */\r\n\t\tthis.removeAll = function(){\r\n\t\t\trouteHandlers = [];\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * If options.greedy is false either fails silently if no match is fund or:\r\n\t\t * 1) Call the exit() method of the previously matched routeHandler\r\n\t\t * 2) Call the enter() method of the first registered routeHandler matching the given fragment\r\n\t\t *\r\n\t\t * If options.greedy is true either fails silently if no match is fund or:\r\n\t\t * 1) Call the exit() method of the previously matched routeHandlers\r\n\t\t * 2) Call the enter() method of all the registered routeHandlers matching the given fragment\r\n\t\t *\r\n\t\t * @param {string} fragment\r\n\t\t */\r\n\t\tthis.resolve = function(fragment){\r\n\t\t\tvar matches = self.getMatch(fragment);\r\n\r\n\t\t\t/** @type {luga.router.routeContext} */\r\n\t\t\tvar context = {\r\n\t\t\t\tfragment: fragment\r\n\t\t\t};\r\n\r\n\t\t\tif((luga.isArray(matches) === false) && (luga.type(matches) !== \"undefined\")){\r\n\t\t\t\texit();\r\n\t\t\t\tenter([matches], context);\r\n\t\t\t}\r\n\t\t\tif(luga.isArray(matches) === true){\r\n\t\t\t\texit();\r\n\t\t\t\tenter(matches, context);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Overwrite the current handlers with the given ones\r\n\t\t * Then execute the enter() method on each of them\r\n\t\t * @param {array.<luga.router.iRouteHandler>} handlers\r\n\t\t * @param {luga.router.routeContext} context\r\n\t\t */\r\n\t\tvar enter = function(handlers, context){\r\n\t\t\tcurrentHandlers = handlers;\r\n\t\t\tcurrentHandlers.forEach(function(element, i, collection){\r\n\t\t\t\telement.enter(context);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute the exit() method on all the current handlers\r\n\t\t */\r\n\t\tvar exit = function(){\r\n\t\t\tcurrentHandlers.forEach(function(element, i, collection){\r\n\t\t\t\telement.exit();\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Change current configuration\r\n\t\t * @param {luga.router.options} options\r\n\t\t * @returns {luga.router.options}\r\n\t\t */\r\n\t\tthis.setup = function(options){\r\n\t\t\tluga.merge(config, options);\r\n\t\t\treturn config;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Bootstrap the Router\r\n\t\t * If inside a browser, start listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.start = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.addEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.addEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Stop the Router\r\n\t\t * If inside a browser, stop listening to the \"hashchange\" and \"popstate\" events\r\n\t\t */\r\n\t\tthis.stop = function(){\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif(window !== undefined){\r\n\t\t\t\twindow.removeEventListener(\"hashchange\", self.onHashChange, false);\r\n\t\t\t\twindow.removeEventListener(\"popstate\", self.onPopstate, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.onHashChange = function(){\r\n\t\t\tself.resolve(location.hash.substring(1));\r\n\t\t};\r\n\r\n\t\tthis.onPopstate = function(){\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());","/**\r\n * @typedef {object} luga.router.iRouteHandler\r\n *\r\n * @property {string} path\r\n * @property {function} enter\r\n * @property {function} exit\r\n * @property {function} match\r\n */\r\n\r\n/**\r\n * @typedef {object} luga.router.iRouteHandler.options\r\n *\r\n * @property {string}           path              Path. Required\r\n * @property {array.<function>} enterCallBacks    Records to be loaded, either one single object containing value/name pairs, or an array of name/value pairs\r\n * @property {array.<function>} exitCallBacks     formatter  A formatting functions to be called once for each row in the dataSet. Default to null\r\n * @property {object} payload\r\n */\r\n\r\n(function(){\r\n\t\"use strict\";\r\n\r\n\t/**\r\n\t * Route class\r\n\t * @param options {luga.router.iRouteHandler.options}\r\n\t * @constructor\r\n\t * @extends luga.router.iRouteHandler\r\n\t */\r\n\tluga.router.RouteHandler = function(options){\r\n\r\n\t\t/**\r\n\t\t * @type {luga.router.iRouteHandler.options}\r\n\t\t */\r\n\t\tvar config = {\r\n\t\t\tpath: \"\",\r\n\t\t\tenterCallBacks: [],\r\n\t\t\texitCallBacks: [],\r\n\t\t\tpayload: undefined\r\n\t\t};\r\n\r\n\t\tluga.merge(config, options);\r\n\r\n\t\t// TODO: turn path into RegExp\r\n\t\tthis.path = config.path;\r\n\r\n\t\t/**\r\n\t\t * Execute registered enter callbacks, if any\r\n\t\t * @param {luga.router.routeContext} context\r\n\t\t */\r\n\t\tthis.enter = function(context){\r\n\t\t\tconfig.enterCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(context, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Execute registered exit callbacks, if any\r\n\t\t */\r\n\t\tthis.exit = function(){\r\n\t\t\tconfig.exitCallBacks.forEach(function(element, i, collection){\r\n\t\t\t\telement.apply(null, []);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Return true if the given fragment matches the Route. False otherwise\r\n\t\t * @param fragment\r\n\t\t * @returns {boolean}\r\n\t\t */\r\n\t\tthis.match = function(fragment){\r\n\t\t\t// TODO: implement pattern matching\r\n\t\t\treturn fragment === config.path;\r\n\t\t};\r\n\r\n\t};\r\n\r\n}());"],"sourceRoot":"."}